{
  "0": "SELECT COUNT(CASE WHEN Currency = 'EUR' THEN CustomerID END) as eur_customers,\n       COUNT(CASE WHEN Currency = 'CZK' THEN CustomerID END) as czk_customers\nFROM customers;\n\nSELECT (eur_customers::FLOAT / czk_customers::FLOAT) as ratio\nFROM (\n    SELECT COUNT(CASE WHEN Currency = 'EUR' THEN CustomerID END) as eur_customers,\n           COUNT(CASE WHEN Currency = 'CZK' THEN CustomerID END) as czk_customers\n    FROM customers\n) as subquery;\t----- bird -----\tdebit_card_specializing",
  "1": "SELECT customers.CustomerID\nFROM customers\nJOIN yearmonth ON customers.CustomerID = yearmonth.CustomerID\nWHERE yearmonth.Date = '2012-01-01' AND yearmonth.Country = 'LAM'\nORDER BY yearmonth.Consumption ASC\nLIMIT 1;\t----- bird -----\tdebit_card_specializing",
  "2": "SELECT AVG(Consumption)\nFROM yearmonth\nWHERE CustomerID IN (\n    SELECT CustomerID\n    FROM customers\n    WHERE Segment = 'SME'\n) AND Date LIKE '2013%';\t----- bird -----\tdebit_card_specializing",
  "3": "SELECT SUM(consumption) as czk_consumption\nFROM yearmonth\nWHERE Customer.Currency = 'CZK' AND YearMonth.Date LIKE '2012%'\n\nUNION ALL\n\nSELECT SUM(consumption) as eur_consumption\nFROM yearmonth\nWHERE Customer.Currency = 'EUR' AND YearMonth.Date LIKE '2012%'\n\nSELECT czk_consumption - eur_consumption as difference\n```\n\nThis SQL code calculates the sum of gas consumption for CZK-paying customers and EUR-paying customers in 2012, then subtracts the EUR consumption from the CZK consumption to find the difference. The `LIKE '2012%'` is used to match any year within 2012 (e.g., '2012-01-01'). The `JOIN` with the `customers` table is assumed to be implicit, as the `CustomerID` is referenced in the `yearmonth` table.\t----- bird -----\tdebit_card_specializing",
  "4": "sql\nSELECT Year(Date), SUM(Consumption) as TotalConsumption\nFROM yearmonth\nJOIN transactions_1k ON yearmonth.CustomerID = transactions_1k.CustomerID AND yearmonth.Date = DATE(transactions_1k.Date, 'start of month')\nWHERE yearmonth.CustomerID IS NOT NULL AND transactions_1k.Currency = 'CZK'\nGROUP BY Year(Date)\nORDER BY Year(Date)\nLIMIT 1;\n```\n\nThis query will join the `yearmonth` and `transactions_1k` tables based on the customer and date, filter for transactions in CZK, group the results by year, and return the year with the most consumption. The `LIMIT 1` at the end ensures that only the year with the most consumption is returned.\t----- bird -----\tdebit_card_specializing",
  "5": "SELECT Date, MAX(Consumption) as PeakConsumption\nFROM yearmonth\nWHERE CustomerID IN (\n    SELECT CustomerID FROM customers WHERE Segment = 'SME' AND Year(Date) = 2013\n)\nGROUP BY Date\nHAVING Year(Date) = 2013;\t----- bird -----\tdebit_card_specializing",
  "6": "WITH least_consumption_sme AS (\n    SELECT CustomerID, AVG(Consumption) as avg_consumption\n    FROM yearmonth\n    WHERE Date LIKE '2013%' AND Segment = 'SME'\n    GROUP BY CustomerID\n    ORDER BY avg_consumption ASC\n    LIMIT 1\n),\nleast_consumption_lam AS (\n    SELECT CustomerID, AVG(Consumption) as avg_consumption\n    FROM yearmonth\n    WHERE Date LIKE '2013%' AND Segment = 'LAM'\n    GROUP BY CustomerID\n    ORDER BY avg_consumption ASC\n    LIMIT 1\n),\nleast_consumption_kam AS (\n    SELECT CustomerID, AVG(Consumption) as avg_consumption\n    FROM yearmonth\n    WHERE Date LIKE '2013%' AND Segment = 'KAM'\n    GROUP BY CustomerID\n    ORDER BY avg_consumption ASC\n    LIMIT 1\n\nSELECT\n    ('SME' - least_consumption_sme.avg_consumption) - (least_consumption_lam.avg_consumption - least_consumption_sme.avg_consumption) as diff_sme_lam,\n    (least_consumption_lam.avg_consumption - least_consumption_kam.avg_consumption) - (least_consumption_sme.avg_consumption - least_consumption_kam.avg_consumption) as diff_lam_kam,\n    (least_consumption_kam.avg_consumption - least_consumption_sme.avg_consumption) as diff_kam_sme\nFROM least_consumption_sme, least_consumption_lam, least_consumption_kam;\n```\n\nThis SQL code calculates the difference in the annual average consumption of customers with the least amount of consumption paid in CZK for 2013 between SME, LAM, and KAM. The result is the difference between the average consumption of the least consuming customer in each segment.\t----- bird -----\tdebit_card_specializing",
  "7": "sql\nWITH segment_consumption AS (\n    SELECT\n        segment,\n        SUM(consumption) AS total_consumption,\n        COUNT(*) AS transaction_count,\n        YEAR(date) AS year,\n        MONTH(date) AS month\n    FROM\n        yearmonth\n    GROUP BY\n        segment,\n        year,\n        month\n),\n\nsegment_year_consumption AS (\n    SELECT\n        segment,\n        year,\n        SUM(total_consumption) AS year_consumption,\n        (SUM(total_consumption) / COUNT(*)) AS avg_consumption_per_transaction\n    FROM\n        segment_consumption\n    GROUP BY\n        segment,\n        year\n),\n\nsegment_year_consumption_change AS (\n    SELECT\n        segment,\n        year,\n        avg_consumption_per_transaction AS consumption_2012,\n        (\n            SELECT\n                avg_consumption_per_transaction\n            FROM\n                segment_year_consumption\n            WHERE\n                segment = s.segment\n                AND year = 2013\n        ) AS consumption_2013,\n        (consumption_2013 - consumption_2012) / consumption_2012 * 100 AS percentage_increase\n    FROM\n        segment_year_consumption s\n)\n\nSELECT\n    segment,\n    MAX(percentage_increase) AS max_percentage_increase,\n    MIN(percentage_increase) AS min_percentage_increase\nFROM\n    segment_year_consumption_change\nWHERE\n    segment IN ('SME', 'LAM', 'KAM')\n    AND year = 2013\nGROUP BY\n    segment;\n```\n\nThis SQLite query calculates the average consumption per transaction for each segment and year, then calculates the percentage increase in consumption between 2012 and 2013 for each segment. The final result provides the segment with the highest and lowest percentage increases in consumption paid in EUR between 2012 and 2013.\t----- bird -----\tdebit_card_specializing",
  "8": "SELECT SUM(Consumption) FROM yearmonth WHERE CustomerID = 6 AND Date BETWEEN '2013-08-01' AND '2013-11-30';\t----- bird -----\tdebit_card_specializing",
  "9": "To answer the question, we first need to create a table that groups the gas stations by country and segment, and counts the number of discount stations. Then, we compare the counts for the Czech Republic and Slovakia.\n\n```sql\nCREATE TABLE gas_stations_counts AS\nSELECT Country, Segment, COUNT(*) as Discount_Count\nFROM gasstations\nWHERE Segment = 'discount'\nGROUP BY Country;\n\nSELECT Discount_Count - (\n    SELECT Discount_Count FROM gas_stations_counts WHERE Country = 'Slovakia'\n) AS Czech_Republic_Excess\nFROM gas_stations_counts WHERE Country = 'Czech Republic';\n```\n\nThis SQL code first creates a temporary table `gas_stations_counts` that contains the number of discount gas stations in each country. Then, it subtracts the number of discount gas stations in Slovakia from the number in the Czech Republic, giving the excess number of discount gas stations in the Czech Republic.\t----- bird -----\tdebit_card_specializing",
  "10": "To answer the question \"Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?\", we first need to count the number of SME segments (assuming SME segment is represented as 'SME' in the Segment column) for each currency in the customers table. Then, we subtract the number of SME segments in euros from the number of SME segments in Czech koruna.\n\nHere's the SQLite query to achieve this:\n\n```sql\nSELECT COUNT(CASE WHEN Segment = 'SME' AND Currency = 'CZK' THEN CustomerID END) - COUNT(CASE WHEN Segment = 'SME' AND Currency = 'EUR' THEN CustomerID END) AS difference\nFROM customers;\n```\n\nThis query will return the difference in the number of SME segments between Czech koruna and euros. If the result is positive, it means more SMEs pay in Czech koruna than in euros.\t----- bird -----\tdebit_card_specializing",
  "11": "SELECT COUNT(c.CustomerID) as total_customers,\n       COUNT(DISTINCT c.CustomerID) FILTER (WHERE t.Amount > 46.73) as customers_with_consumption_more_than_46_73,\n       (COUNT(DISTINCT c.CustomerID) FILTER (WHERE t.Amount > 46.73) / COUNT(c.CustomerID)) * 100 as percentage\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nWHERE c.Segment = 'LAM';\n```\n\nThis SQL query calculates the percentage of LAM customers who consumed more than 46.73. It first counts the total number of LAM customers, then counts the number of LAM customers who have consumed more than 46.73, and finally calculates the percentage by dividing the number of customers with consumption more than 46.73 by the total number of LAM customers and multiplying by 100.\t----- bird -----\tdebit_card_specializing",
  "12": "SELECT COUNT(DISTINCT c.CustomerID) as total_customers,\n       COUNT(DISTINCT CASE WHEN ym.Consumption > 528.3 THEN c.CustomerID END) as customers_consumed_more\nFROM customers c\nJOIN yearmonth ym ON c.CustomerID = ym.CustomerID\nWHERE ym.Date = '2012-02'\n\nSELECT (customers_consumed_more / total_customers) * 100 as percentage\nFROM (\n    SELECT COUNT(DISTINCT c.CustomerID) as total_customers,\n           COUNT(DISTINCT CASE WHEN ym.Consumption > 528.3 THEN c.CustomerID END) as customers_consumed_more\n    FROM customers c\n    JOIN yearmonth ym ON c.CustomerID = ym.CustomerID\n    WHERE ym.Date = '2012-02'\n) as subquery\t----- bird -----\tdebit_card_specializing",
  "13": "SELECT MAX(Consumption)\nFROM yearmonth\nWHERE EXTRACT(YEAR FROM Date) = 2012;\t----- bird -----\tdebit_card_specializing",
  "14": "SELECT products.Description\nFROM products\nJOIN transactions_1k ON transactions_1k.ProductID = products.ProductID\nJOIN yearmonth ON transactions_1k.TransactionID = yearmonth.TransactionID\nWHERE yearmonth.Date = '2013-09' AND yearmonth.CustomerID IS NOT NULL;\t----- bird -----\tdebit_card_specializing",
  "15": "SELECT Country\nFROM gasstations\nJOIN transactions_1k ON gasstations.GasStationID = transactions_1k.GasStationID\nWHERE transactions_1k.Date = '2013-06-01' AND transactions_1k.Date = DATE('now', '+1 month', '-1 month')\t----- bird -----\tdebit_card_specializing",
  "16": "SELECT COUNT(DISTINCT c.CustomerID)\nFROM customers c\nJOIN transactions_1k t ON c.CustomerID = t.CustomerID\nJOIN yearmonth y ON y.CustomerID = c.CustomerID AND y.Date = STRFTIME('%Y-%m', t.Date)\nWHERE c.Currency = 'Euro' AND y.Consumption > 1000;\t----- bird -----\tdebit_card_specializing",
  "17": "SELECT products.Description\nFROM transactions_1k\nJOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID\nJOIN yearmonth ON transactions_1k.CustomerID = yearmonth.CustomerID\nJOIN customers ON yearmonth.CustomerID = customers.CustomerID\nWHERE gasstations.Country = 'Czech Republic';\t----- bird -----\tdebit_card_specializing",
  "18": "SELECT DISTINCT transactions_1k.Time\nFROM transactions_1k\nJOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID\nWHERE gasstations.ChainID = 11;\t----- bird -----\tdebit_card_specializing",
  "19": "SELECT COUNT(*)\nFROM transactions_1k\nJOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID\nWHERE gasstations.Country = 'Czech Republic' AND strftime('%Y-%m-%d', transactions_1k.Date, 'localtime') > '2012-01-01';\t----- bird -----\tdebit_card_specializing",
  "20": "SELECT Currency\nFROM transactions_1k\nWHERE Date = '2012-08-24' AND Time = '16:25:00';\t----- bird -----\tdebit_card_specializing",
  "21": "SELECT Segment\nFROM customers\nJOIN yearmonth ON customers.CustomerID = yearmonth.CustomerID\nWHERE yearmonth.Date = '2012-08-23' AND yearmonth.Date || ' ' || yearmonth.CustomerID IN (\n    SELECT CustomerID\n    FROM transactions_1k\n    WHERE Date = '2012-08-23' AND Time = '21:20:00'\n)\nLIMIT 1;\t----- bird -----\tdebit_card_specializing",
  "22": "SELECT COUNT(*)\nFROM transactions_1k\nWHERE Date = '2012-08-26' AND Time BETWEEN '08:00:00' AND '09:00:00' AND Country = 'CZE';\t----- bird -----\tdebit_card_specializing",
  "23": "SELECT country\nFROM gasstations\nJOIN transactions_1k ON gasstations.GasStationID = transactions_1k.GasStationID\nWHERE transactions_1k.CustomerID = (\n    SELECT CustomerID\n    FROM customers\n    JOIN transactions_1k ON customers.CustomerID = transactions_1k.CustomerID\n    WHERE transactions_1k.Amount = 548.4 AND transactions_1k.Date = '2012-08-24'\n)\nLIMIT 1;\t----- bird -----\tdebit_card_specializing",
  "24": "SELECT COUNT(*) as total_customers, COUNT(CASE WHEN currency = 'EUR' THEN customerid END) as eur_customers\nFROM customers\nJOIN yearmonth ON customers.customerid = yearmonth.customerid\nWHERE yearmonth.date = '2012-08-25'\n\nSELECT (COUNT(CASE WHEN currency = 'EUR' THEN customerid END) / COUNT(*)) * 100 as percentage\nFROM (\n    SELECT customerid\n    FROM customers\n    JOIN yearmonth ON customers.customerid = yearmonth.customerid\n    WHERE yearmonth.date = '2012-08-25'\n) as subquery\t----- bird -----\tdebit_card_specializing",
  "25": "sql\nSELECT\n    (Consumption_2013 - Consumption_2012) / Consumption_2012 as consumption_decrease_rate\nFROM\n    (\n        SELECT\n            c.CustomerID,\n            SUM(t1.Amount) as Consumption_2012,\n            SUM(t2.Amount) as Consumption_2013\n        FROM\n            customers c\n        JOIN\n            transactions_1k t1 ON c.CustomerID = t1.CustomerID AND t1.Date LIKE '2012-%'\n        JOIN\n            transactions_1k t2 ON c.CustomerID = t2.CustomerID AND t2.Date LIKE '2013-%'\n        WHERE\n            t1.Date = '2012/08/25' AND t1.Amount = 634.8\n        GROUP BY c.CustomerID\n    ) as consumption_by_year\t----- bird -----\tdebit_card_specializing",
  "26": "SELECT ROUND(100 * SUM(CASE WHEN segment = 'premium' THEN 1 ELSE 0 END) /\n             (SELECT COUNT(*) FROM transactions_1k JOIN customers ON transactions_1k.CustomerID = customers.CustomerID WHERE country = 'SVK' AND transactions_1k.Segment IS NOT NULL), 2) AS percentage\nFROM transactions_1k JOIN customers ON transactions_1k.CustomerID = customers.CustomerID\nWHERE country = 'SVK' AND transactions_1k.Segment IS NOT NULL AND transactions_1k.segment = 'premium'\t----- bird -----\tdebit_card_specializing",
  "27": "SELECT SUM(Price)\nFROM transactions_1k\nWHERE CustomerID = 38508;\n\nSELECT SUM(Consumption)\nFROM yearmonth\nWHERE CustomerID = 38508 AND Date = '2012-01-01';\t----- bird -----\tdebit_card_specializing",
  "28": "sql\nSELECT customers.CustomerID, AVG(products.Amount) as AverageItems, transactions_1k.Price as AveragePrice, transactions_1k.Currency\nFROM customers\nJOIN transactions_1k ON customers.CustomerID = transactions_1k.CustomerID\nJOIN products ON transactions_1k.ProductID = products.ProductID\nWHERE customers.CustomerID = (\n    SELECT CustomerID\n    FROM customers\n    JOIN (\n        SELECT CustomerID, SUM(Amount) as TotalSpending\n        FROM transactions_1k\n        GROUP BY CustomerID\n        ORDER BY TotalSpending DESC\n        LIMIT 1\n    ) as Spending\n    ON customers.CustomerID = Spending.CustomerID\n)\nGROUP BY customers.CustomerID\t----- bird -----\tdebit_card_specializing",
  "29": "SELECT c.CustomerID, ym.Consumption\nFROM transactions_1k t\nJOIN products p ON t.ProductID = p.ProductID AND p.ProductID = 5\nJOIN yearmonth ym ON t.CustomerID = ym.CustomerID AND ym.Date = '2012-08-01'\nWHERE t.Price > 29.00\t----- bird -----\tdebit_card_specializing",
  "30": "SELECT department, college FROM major JOIN member ON major.major_id = member.link_to_major WHERE member.last_name = 'Sanders' AND member.first_name = 'Angela';\t----- bird -----\tstudent_club",
  "31": "SELECT COUNT(*)\nFROM member\nWHERE link_to_major IN (\n    SELECT major_id FROM major\n    WHERE department = 'Student_Club'\n) AND t_shirt_size = 'medium' AND link_to_attendance IN (\n    SELECT link_to_member FROM attendance\n    WHERE link_to_event = 'Women\\'s Soccer'\n);\t----- bird -----\tstudent_club",
  "32": "SELECT COUNT(*)\nFROM attendance\nJOIN event ON attendance.link_to_event = event.event_id\nJOIN member ON attendance.link_to_member = member.member_id\nWHERE event.type = 'meeting' AND (\n    SELECT COUNT(*) FROM attendance WHERE link_to_event = event.event_id GROUP BY link_to_event HAVING COUNT(*) > 10\n)\t----- bird -----\tstudent_club",
  "33": "SELECT event_name\nFROM event\nJOIN attendance ON event.event_id = attendance.link_to_event\nJOIN member ON attendance.link_to_member = member.member_id\nWHERE event.type != 'Fundraiser' AND COUNT(member.member_id) > 20\t----- bird -----\tstudent_club",
  "34": "SELECT amount FROM income WHERE link_to_member = (SELECT member_id FROM member WHERE position = 'Vice President')\t----- bird -----\tstudent_club",
  "35": "SELECT first_name || ' ' || last_name\nFROM member\nJOIN zip_code ON member.zip = zip_code.zip_code\nWHERE zip_code.state = 'Illinois'\t----- bird -----\tstudent_club",
  "36": "SELECT approved FROM expense\nWHERE link_to_event = 'October Meeting'\nAND event_date = '2019-10-08';\t----- bird -----\tstudent_club",
  "37": "SELECT AVG(e.cost)\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event eve ON b.link_to_event = eve.event_id\nJOIN member m ON e.link_to_member = m.member_id\nWHERE m.last_name = 'Allen' AND m.first_name = 'Elijah' AND eve.event_date LIKE '202X-09-%' OR eve.event_date LIKE '202X-10-%';\t----- bird -----\tstudent_club",
  "38": "SELECT SUM(b.spent) as total_spent_2019 FROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_date LIKE '2019%' AND b.category = 'Student_Club';\n\nSELECT SUM(b.spent) as total_spent_2020 FROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_date LIKE '2020%' AND b.category = 'Student_Club';\n\nSELECT (SUM(b.spent) as total_spent_2020 - SUM(b.spent) as total_spent_2019) as difference FROM budget b\nJOIN event e ON b.link_to_event = e.event_id\nWHERE e.event_date LIKE '2019%' OR e.event_date LIKE '2020%' AND b.category = 'Student_Club';\t----- bird -----\tstudent_club",
  "39": "SELECT notes FROM event WHERE event_date = '2019/9/14';\t----- bird -----\tstudent_club",
  "40": "SELECT phone FROM member WHERE first_name = 'Carlo' AND last_name = 'Jacobs';\t----- bird -----\tstudent_club",
  "41": "SELECT status FROM event\nJOIN budget ON event.event_id = budget.link_to_event\nWHERE expense_description = 'Post Cards, Posters' AND expense_date = '2019/8/20';\t----- bird -----\tstudent_club",
  "42": "SELECT major_name\nFROM major\nJOIN member\nON major.major_id = member.link_to_major\nWHERE member.last_name = 'Thomason' AND member.first_name = 'Brent';\t----- bird -----\tstudent_club",
  "43": "SELECT COUNT(*)\nFROM member\nWHERE major_name = 'Business' AND t_shirt_size = 'medium';\t----- bird -----\tstudent_club",
  "44": "SELECT department FROM major WHERE major_name = (SELECT position FROM member WHERE member_id = (SELECT link_to_major FROM member WHERE first_name = 'President' AND last_name = 'President'));\t----- bird -----\tstudent_club",
  "45": "SELECT date_received FROM income WHERE link_to_member = (SELECT member_id FROM member WHERE first_name = 'Connor' AND last_name = 'Hilton');\t----- bird -----\tstudent_club",
  "46": "SELECT COUNT(*)\nFROM budget\nWHERE category = 'Advertisement' AND event_status = 'Yearly Kickoff' AND expense_date > (SELECT event_date FROM event WHERE event_name = 'October Meeting')\t----- bird -----\tstudent_club",
  "47": "SELECT SUM(p.cost) as total_cost\nFROM expense e\nJOIN budget b ON e.link_to_budget = b.budget_id\nJOIN event eve ON b.link_to_event = eve.event_id\nJOIN pizza_expense pe ON e.expense_id = pe.expense_id\nJOIN pizza p ON pe.pizza_id = p.pizza_id\nWHERE p.pizza_type = 'Pizza';\n```\n\nAssuming there is a table `pizza_expense` that links `expense` and `pizza` tables, and `pizza_type` is a column in the `pizza` table. This SQL statement calculates the total cost of pizzas for all events by joining the necessary tables and summing the cost of each pizza expense.\t----- bird -----\tstudent_club",
  "48": "SELECT COUNT(DISTINCT city) FROM zip_code WHERE county = 'Orange County' AND state = 'Virginia';\t----- bird -----\tstudent_club",
  "49": "SELECT department FROM major JOIN member ON major.major_id = member.link_to_major WHERE member.phone = '809-555-3360';\t----- bird -----\tstudent_club",
  "50": "SELECT COUNT(*) FROM attendance\nWHERE link_to_event = 'Women\\'s Soccer'\t----- bird -----\tstudent_club",
  "51": "SELECT m.member_id, m.first_name, m.last_name\nFROM member m\nJOIN major ma ON m.link_to_major = ma.major_id\nWHERE ma.department = 'School of Applied Sciences, Technology and Education';\t----- bird -----\tstudent_club",
  "52": "SELECT event_name, (spent / remaining) AS spend_to_budget_ratio\nFROM event\nJOIN budget ON event.event_id = budget.link_to_event\nJOIN attendance ON event.event_id = attendance.link_to_event\nJOIN member ON attendance.link_to_member = member.member_id\nWHERE event.status = 'closed' AND budget.remaining > 0\nGROUP BY event_name\nORDER BY spend_to_budget_ratio DESC\nLIMIT 1;\n```\n\nThis query selects the event name and the spend-to-budget ratio for all closed events with remaining budget, joins the necessary tables, groups the results by event name, orders them by the spend-to-budget ratio in descending order, and returns the event with the highest spend-to-budget ratio.\t----- bird -----\tstudent_club",
  "53": "SELECT MAX(spent) FROM budget;\t----- bird -----\tstudent_club",
  "54": "SELECT SUM(cost) as total_spent_on_food\nFROM expense\nWHERE expense_description LIKE '%food%';\n```\n\nThis SQL statement selects the total amount spent on food by summing the cost column from the expense table, filtering the results where the expense description contains the word 'food'.\t----- bird -----\tstudent_club",
  "55": "SELECT m.first_name || ' ' || m.last_name\nFROM member m\nJOIN attendance a ON m.member_id = a.link_to_member\nWHERE m.member_id IN (\n    SELECT link_to_member\n    FROM attendance\n    GROUP BY link_to_member\n    HAVING COUNT(*) > 7\n)\t----- bird -----\tstudent_club",
  "56": "SELECT member_id\nFROM member\nJOIN budget ON member.link_to_major = budget.link_to_event\nWHERE budget.event_name = 'Yearly Kickoff' AND position = 'Budget Manager';\t----- bird -----\tstudent_club",
  "57": "SELECT event_id, MIN(SUM(cost)) as lowest_cost\nFROM expense\nJOIN budget ON expense.link_to_budget = budget.budget_id\nGROUP BY event_id;\t----- bird -----\tstudent_club",
  "58": "To find the total cost for all events and the cost for the Yearly Kickoff event, and then calculate the percentage for the Yearly Kickoff event, you can use the following SQLite query:\n\n```sql\nSELECT\n    (SUM(budget.spent) - SUM(income.amount)) AS total_cost,\n    (SUM(CASE WHEN event.event_name = 'Yearly Kickoff' THEN budget.spent ELSE 0 END) - SUM(CASE WHEN event.event_name = 'Yearly Kickoff' THEN income.amount ELSE 0 END)) AS yearly_kickoff_cost,\n    (1 - (CAST(yearly_kickoff_cost AS REAL) / CAST(total_cost AS REAL))) * 100 AS percentage\nFROM\n    event\nJOIN\n    budget ON event.event_id = budget.link_to_event\nLEFT JOIN\n    income ON event.event_id = income.link_to_event\nGROUP BY\n    event.event_name;\n```\n\nThis query calculates the total cost by subtracting the total income from the total expenses. It then calculates the cost for the Yearly Kickoff event by filtering the budget and income for that event. Finally, it calculates the percentage of the Yearly Kickoff event cost by dividing the Yearly Kickoff cost by the total cost and multiplying by 100.\t----- bird -----\tstudent_club",
  "59": "SELECT source, SUM(amount) as total_amount\nFROM income\nWHERE date_received LIKE '2019-09-%'\nGROUP BY source\nORDER BY total_amount DESC\nLIMIT 1;\n```\n\nThis SQL statement selects the source and the total amount of funds received in September 2019 from the \"income\" table, groups the results by source, orders them in descending order, and returns the top result (the source with the highest total amount) by using the LIMIT clause.\t----- bird -----\tstudent_club",
  "60": "SELECT COUNT(*)\nFROM member\nJOIN major ON member.link_to_major = major.major_id\nWHERE major.major_name = 'Physics Teaching';\t----- bird -----\tstudent_club",
  "61": "SELECT event_name, SUM(cost) as total_advertisement_cost\nFROM expense\nWHERE expense_description LIKE '%advertisement%'\nGROUP BY link_to_event\nORDER BY total_advertisement_cost DESC\nLIMIT 1;\n```\n\nThis SQL query will return the name of the event with the highest amount spent on advertisement. It groups the expenses by event, filters for expenses related to advertisement, sums up the cost for each event, orders the results in descending order, and returns the top result (the event with the highest total advertisement cost).\t----- bird -----\tstudent_club",
  "62": "SELECT EXISTS(SELECT 1 FROM attendance WHERE link_to_event = 'Women\\'s Soccer' AND link_to_member = (SELECT member_id FROM member WHERE first_name = 'Maya' AND last_name = 'McLean'));\t----- bird -----\tstudent_club",
  "63": "SELECT cost FROM expense WHERE expense_description = 'Posters for September Speaker' event AND approved = 'Yes';\t----- bird -----\tstudent_club",
  "64": "SELECT event_name, SUM(cost) as total_exceeded_budget\nFROM expense\nJOIN budget ON expense.link_to_budget = budget.budget_id\nJOIN event ON budget.link_to_event = event.event_id\nWHERE event.status = 'closed'\nGROUP BY event_name\nORDER BY total_exceeded_budget DESC\nLIMIT 1;\n```\n\nThis query calculates the total cost of expenses for each closed event, joins the relevant tables, groups the results by event name, orders them in descending order, and returns the event with the highest total cost that exceeded the budget.\t----- bird -----\tstudent_club",
  "65": "SELECT SUM(cost) as total_approved_expenses\nFROM expense\nWHERE approved = 'approved' AND link_to_event = (SELECT event_id FROM event WHERE event_name = 'October Meeting');\t----- bird -----\tstudent_club",
  "66": "SELECT SUM(budgeted_amount) as total_budgeted\nFROM (\n    SELECT category, spent + remaining as budgeted_amount\n    FROM budget\n    WHERE link_to_event = 'April Speaker'\n) as budget_data\n```\n\nTo get the budgeted categories for the 'April Speaker' event in an ascending order based on their amount budgeted, use the following SQLite SQL code:\n\n```\nSELECT category, budgeted_amount\nFROM (\n    SELECT category, spent + remaining as budgeted_amount,\n           ROW_NUMBER() OVER (ORDER BY budgeted_amount ASC) as row_num\n    FROM budget\n    WHERE link_to_event = 'April Speaker'\n) as budget_data\nWHERE row_num = 1\nUNION ALL\nSELECT category, budgeted_amount\nFROM (\n    SELECT category, spent + remaining as budgeted_amount,\n           ROW_NUMBER() OVER (ORDER BY budgeted_amount ASC) as row_num\n    FROM budget\n    WHERE link_to_event = 'April Speaker'\n) as budget_data\nWHERE row_num > 1\nORDER BY budgeted_amount ASC\t----- bird -----\tstudent_club",
  "67": "SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20';\t----- bird -----\tstudent_club",
  "68": "SELECT member.first_name || ' ' || member.last_name AS full_name, SUM(expense.cost) AS total_cost\nFROM member\nJOIN attendance ON member.member_id = attendance.link_to_member\nJOIN expense ON attendance.link_to_member = member.member_id\nWHERE member.member_id = 'rec4BLdZHS2Blfp4v'\nGROUP BY member.member_id;\t----- bird -----\tstudent_club",
  "69": "SELECT expense_description FROM expense WHERE link_to_member = 'Sacha Harrison';\t----- bird -----\tstudent_club",
  "70": "SELECT event_name, event_date FROM event\nJOIN attendance ON event.event_id = attendance.link_to_event\nJOIN member ON attendance.link_to_member = member.member_id\nWHERE member.zip = (SELECT zip_code FROM zip_code WHERE city = 'MU' AND state = '215')\t----- bird -----\tstudent_club",
  "71": "SELECT member.last_name, major.department, major.college\nFROM member\nJOIN major ON member.link_to_major = major.major_id\nWHERE major.major_name = 'environmental engineering';\t----- bird -----\tstudent_club",
  "72": "SELECT category FROM budget\nWHERE link_to_event IN (\n    SELECT event_id FROM event\n    WHERE location = 'MU 215' AND type = 'guest speaker'\n) AND spent = 0;\t----- bird -----\tstudent_club",
  "73": "SELECT ROUND(100 * SUM(income_amount) / (SELECT SUM(income_amount) FROM income WHERE link_to_member IN (\n    SELECT member_id FROM member WHERE t_shirt_size = 'medium' AND position = 'Student_Club'\n)), 2) AS percentage\nFROM income\nWHERE link_to_member IN (\n    SELECT member_id FROM member WHERE t_shirt_size = 'medium' AND position = 'Student_Club'\n) AND source = 'Student_Club';\t----- bird -----\tstudent_club",
  "74": "SELECT event_name\nFROM event\nINNER JOIN (\n    SELECT event_id\n    FROM event\n    WHERE type = 'game' AND event_date BETWEEN '2019-03-15' AND '2020-03-20' AND status = 'closed'\n) as closed_games\nON event.event_id = closed_games.event_id;\t----- bird -----\tstudent_club",
  "75": "SELECT m.first_name || ' ' || m.last_name as full_name, m.phone\nFROM member m\nJOIN (\n    SELECT link_to_member, AVG(cost) as avg_cost\n    FROM expense\n    GROUP BY link_to_member\n) avg_expenses\nON m.member_id = avg_expenses.link_to_member\nWHERE m.member_id IN (\n    SELECT link_to_member\n    FROM expense\n    WHERE cost > avg_expenses.avg_cost\n)\t----- bird -----\tstudent_club",
  "76": "SELECT first_name || ' ' || last_name AS full_name, SUM(cost) AS total_cost\nFROM expense\nJOIN member ON link_to_member = member.member_id\nWHERE expense_description IN ('water', 'veggie tray', 'supplies')\nGROUP BY link_to_member\nHAVING full_name IS NOT NULL;\t----- bird -----\tstudent_club",
  "77": "SELECT member.first_name || ' ' || member.last_name, income.amount\nFROM member\nJOIN income\nON member.member_id = income.link_to_member\nWHERE income.date_received = '9/9/2019';\t----- bird -----\tstudent_club",
  "78": "SELECT\n    'In-patient' AS Group,\n    SUM(CASE WHEN Admission = 'In-patient' AND SEX = 'Male' THEN 1 ELSE 0 END) AS Male_Inpatients,\n    COUNT(*) AS Total_Inpatients,\n    ROUND(100 * SUM(CASE WHEN Admission = 'In-patient' AND SEX = 'Male' THEN 1 ELSE 0 END) / COUNT(*), 2) AS Percentage_Male_Inpatients\nFROM Patient\nWHERE Admission = 'In-patient'\n\nUNION ALL\n\nSELECT\n    'Outpatient' AS Group,\n    SUM(CASE WHEN Admission = 'Outpatient' AND SEX = 'Male' THEN 1 ELSE 0 END) AS Male_Outpatients,\n    COUNT(*) AS Total_Outpatients,\n    ROUND(100 * SUM(CASE WHEN Admission = 'Outpatient' AND SEX = 'Male' THEN 1 ELSE 0 END) / COUNT(*), 2) AS Percentage_Male_Outpatients\nFROM Patient\nWHERE Admission = 'Outpatient'\n```\n\nThis SQL code will return the number of male inpatients and outpatients, as well as the percentage deviation between them.\t----- bird -----\tthrombosis_prediction",
  "79": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM Patient WHERE SEX = 'Female') AS Percentage\nFROM Patient\nWHERE SEX = 'Female' AND Birthday > '1930-01-01';\n```\n\nThis SQL statement calculates the percentage of female patients born after 1930 by dividing the count of female patients born after 1930 by the total count of female patients and multiplying the result by 100.\t----- bird -----\tthrombosis_prediction",
  "80": "To answer the question, we first need to create a table for the diagnosis of patients and mark those diagnosed with SLE. Then, we can count the number of outpatient and inpatient follow-ups for SLE patients.\n\n```sqlite\nCREATE TABLE Diagnosis\n(\n    ID           INTEGER default 0 not null,\n    Diagnosis    TEXT  null,\n    PatientID    INTEGER not null,\n    foreign key (ID) references Patient (ID)\n            on update cascade on delete cascade\n)\n\n-- Mark SLE patients\nUPDATE Diagnosis\nSET Diagnosis = 'SLE'\nWHERE Diagnosis = 'Systemic Lupus Erythematosus';\n\n-- Count outpatient and inpatient follow-ups for SLE patients\nSELECT\n    COUNT(CASE WHEN Admission = 'Outpatient' THEN ID END) AS Outpatient,\n    COUNT(CASE WHEN Admission = 'Inpatient' THEN ID END) AS Inpatient\nFROM Diagnosis\nWHERE Diagnosis = 'SLE';\n```\n\nThis SQLite code will first create a table for diagnoses, then mark the patients diagnosed with SLE, and finally count the number of outpatient and inpatient follow-ups for SLE patients. The result will be the ratio of outpatient to inpatient follow-ups among all the SLE diagnosed patients.\t----- bird -----\tthrombosis_prediction",
  "81": "SELECT Diagnosis\nFROM Patient\nWHERE ID = 30609;\n\nSELECT Laboratory.Date\nFROM Laboratory\nWHERE Laboratory.ID = (\n    SELECT ID FROM Patient WHERE ID = 30609\n);\t----- bird -----\tthrombosis_prediction",
  "82": "SELECT ID, SEX, Birthday\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE LDH > (SELECT LDH_normal FROM Normal_Values WHERE Test = 'Laboratory')\nAND Laboratory.Date IS NOT NULL;\t----- bird -----\tthrombosis_prediction",
  "83": "SELECT Patient.ID, DATEDIF(Patient.Birthday, 'now', 'year') as Age\nFROM Patient\nJOIN Examination ON Patient.ID = Examination.ID\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Examination.Thrombosis = 1 AND Laboratory.PT < 15.0 AND Laboratory.APTT < 35.0\n```\n\nThis SQLite query selects the ID and age of patients with a positive degree of coagulation. It joins the three tables (Patient, Examination, and Laboratory) based on the ID, filters the results where the Thrombosis value in the Examination table is 1 (indicating a positive degree of coagulation), and checks if the PT and APTT values in the Laboratory table are below the specified thresholds (15.0 and 35.0, respectively). The DATEDIF function is used to calculate the age of the patient.\t----- bird -----\tthrombosis_prediction",
  "84": "SELECT ID, SEX, Diagnosis\nFROM Patient\nJOIN Examination ON Patient.ID = Examination.ID\nWHERE Thrombosis = 'severe' AND Examination.ID = (\n    SELECT Examination.ID\n    FROM Examination\n    JOIN Patient ON Examination.ID = Patient.ID\n    WHERE Thrombosis = 'severe'\n    GROUP BY Examination.ID\n    HAVING COUNT(*) > 1\n)\t----- bird -----\tthrombosis_prediction",
  "85": "SELECT COUNT(P.ID)\nFROM Patient AS P\nJOIN Laboratory AS L ON P.ID = L.ID\nWHERE P.SEX = 'Female' AND L.Date = '1997-01-01'\nAND L.Admission IS NOT NULL AND L.KCT IS NOT NULL;\n```\n\nThis query selects the count of female patients who came at the hospital in 1997, and were immediately followed at the outpatient clinic, based on the presence of admission and KCT values in the Laboratory table.\t----- bird -----\tthrombosis_prediction",
  "86": "SELECT COUNT(P.ID)\nFROM Patient AS P\nJOIN Examination AS E ON P.ID = E.ID\nJOIN Laboratory AS L ON P.ID = L.ID\nWHERE E.Thrombosis = (SELECT MAX(Thrombosis) FROM Examination)\nAND L.Date = '1997-01-01'\nAND P.SEX = 'Female';\t----- bird -----\tthrombosis_prediction",
  "87": "sql\nSELECT Symptoms, Diagnosis\nFROM Patient\nJOIN Examination ON Patient.ID = Examination.ID\nJOIN Laboratory ON Patient.ID = Laboratory.ID AND Laboratory.Date = (\n    SELECT Laboratory.Date\n    FROM Laboratory\n    WHERE Patient.ID = Laboratory.ID\n    ORDER BY Laboratory.Date ASC\n    LIMIT 1\n)\nWHERE Patient.Birthday = (\n    SELECT Birthday\n    FROM Patient\n    ORDER BY Birthday ASC\n    LIMIT 1\n)\t----- bird -----\tthrombosis_prediction",
  "88": "SELECT `Laboratory`.Date, Patient.Birthday, DATEDIF('Laboratory'.Date, Patient.Birthday, 'year') as Age\nFROM Laboratory\nJOIN Patient ON Laboratory.ID = Patient.ID\nJOIN Examination ON Patient.ID = Examination.ID\nWHERE Examination.Diagnosis = 'SJS'\nORDER BY Laboratory.Date ASC\nLIMIT 1;\n```\n\nThis SQL query will find the oldest laboratory record for a patient diagnosed with SJS, along with the patient's birthdate and the age they were when they initially arrived at the hospital. The result will be ordered by the laboratory date in ascending order, and only the first (oldest) record will be returned using the LIMIT clause.\t----- bird -----\tthrombosis_prediction",
  "89": "SELECT COUNT(CASE WHEN SEX = 'Male' AND UA > normal_value THEN 1 END) as male_count,\n       COUNT(CASE WHEN SEX = 'Female' AND UA > normal_value THEN 1 END) as female_count\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE UA > normal_value\n```\n\nAssuming that you have a known normal value for uric acid (`normal_value`) and the `SEX` column in the `Patient` table represents the gender of the patient. This SQL query will count the number of male and female patients with abnormal uric acid counts.\t----- bird -----\tthrombosis_prediction",
  "90": "SELECT COUNT(P.ID)\nFROM Patient AS P\nJOIN Examination AS E ON P.ID = E.ID\nWHERE P.Birthday < '1990-01-01' AND P.Birthday >= '1993-01-01' AND E.Examination Date BETWEEN '1990-01-01' AND '1993-12-31';\t----- bird -----\tthrombosis_prediction",
  "91": "SQL\nSELECT Patient.Birthday, Laboratory.HGB, Examination.Diagnosis\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nJOIN Examination ON Laboratory.ID = Examination.ID\nWHERE Laboratory.HGB = (SELECT MAX(Laboratory.HGB) FROM Laboratory)\n```\n\nThis query will return the birthdate, highest hemoglobin count, and diagnosis for the patient who had the highest hemoglobin count during an examination.\t----- bird -----\tthrombosis_prediction",
  "92": "SELECT `aCL IgG`, `aCL IgM`\nFROM Examination\nJOIN Laboratory ON Examination.ID = Laboratory.ID AND Laboratory.Date = '1993-11-12'\nJOIN Patient ON Examination.ID = Patient.ID\nWHERE Patient.Diagnosis = 'SLE' AND Patient.`First Date` = '1994-02-19';\t----- bird -----\tthrombosis_prediction",
  "93": "SELECT (Laboratory.T_CHO December - Laboratory.T_CHO November) as Total_Cholesterol_Decrease_Rate\nFROM Laboratory\nJOIN Patient ON Laboratory.ID = Patient.ID\nWHERE Patient.Birthday = '1959-02-18'\nAND Laboratory.Date BETWEEN '1981-11-01' AND '1981-12-31';\t----- bird -----\tthrombosis_prediction",
  "94": "SELECT ID\nFROM Patient\nJOIN Examination ON Patient.ID = Examination.ID\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Examination.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31'\nAND Laboratory.GPT > 30\nAND Laboratory.ALB < 4;\t----- bird -----\tthrombosis_prediction",
  "95": "SELECT ID\nFROM Examination\nWHERE Thrombosis = 2 AND ANA_Pattern = 'S' AND `aCL IgM` > (SELECT AVG(`aCL IgM`) FROM Examination)\t----- bird -----\tthrombosis_prediction",
  "96": "SELECT Patient.ID\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Laboratory.Date = '1991-10-01'\nAND Laboratory.`T-BIL` <= 1.2\nAND Admission = 'Outpatient';\t----- bird -----\tthrombosis_prediction",
  "97": "SELECT AVG(Laboratory.ALB)\nFROM Laboratory\nJOIN Patient ON Laboratory.ID = Patient.ID\nWHERE Patient.SEX = 'Female' AND Laboratory.PLT > 400 AND Patient.Diagnosis = 'SLE'\t----- bird -----\tthrombosis_prediction",
  "98": "SELECT COUNT(ID)\nFROM Patient\nINNER JOIN Examination ON Patient.ID = Examination.ID\nWHERE Patient.SEX = 'Female' AND Diagnosis = 'APS';\t----- bird -----\tthrombosis_prediction",
  "99": "SELECT COUNT(P.ID) as total_women, COUNT(CASE WHEN P.Sex = 'Female' AND P.Birthday = '1980-01-01' AND L.RA = 'Yes' THEN P.ID END) as rA_women\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Birthday = '1980-01-01' AND L.RA = 'Yes'\n\nSELECT (COUNT(CASE WHEN P.Sex = 'Female' AND P.Birthday = '1980-01-01' AND L.RA = 'Yes' THEN P.ID END) / COUNT(P.ID)) * 100 as percentage\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.Birthday = '1980-01-01' AND L.RA = 'Yes'\n```\n\nThis SQL code first counts the number of women born in 1980 who were diagnosed with RA and the total number of patients born in 1980 who were diagnosed with RA. Then it calculates the percentage of women among those patients.\t----- bird -----\tthrombosis_prediction",
  "100": "SELECT CASE WHEN `T-CHO` < 6.8 AND `T-CHO` > 3.5 THEN 'Within Normal Range' ELSE 'Outside Normal Range' END\nFROM Laboratory\nWHERE ID = 57266\t----- bird -----\tthrombosis_prediction",
  "101": "SELECT P.ID\nFROM Patient P\nJOIN Laboratory L ON P.ID = L.ID\nWHERE P.SEX = 'Male'\nAND L.GPT > (SELECT MAX(GPT) FROM Laboratory WHERE GPT IS NOT NULL AND ID = P.ID)\nAND L.Date < (SELECT MAX(Date) FROM Laboratory WHERE GPT IS NOT NULL AND ID = P.ID)\n```\n\nThis SQL query selects the IDs of male patients who have a history of GPT exceeding the normal range. It first joins the Patient and Laboratory tables on the ID field. Then it filters the results to only include rows where the patient's sex is male, the GPT value is greater than the maximum GPT value for that patient where GPT is not null, and the laboratory date is less than the maximum date for that patient where GPT is not null. This ensures that we are only considering past GPT values that exceeded the normal range.\t----- bird -----\tthrombosis_prediction",
  "102": "SELECT Patient.ID, Patient.Birthday, Laboratory.ALT\n        FROM Patient\n        JOIN Laboratory ON Patient.ID = Laboratory.ID\n        WHERE Laboratory.ALT > (SELECT AVG(Laboratory.ALT) FROM Laboratory)\n        AND Laboratory.ALT IS NOT NULL\n        ORDER BY Patient.Birthday ASC;\t----- bird -----\tthrombosis_prediction",
  "103": "SELECT ID, SEX, Birthday\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Laboratory.UN BETWEEN 20 AND 40;\n```\n\nThis SQL query will return the ID, sex, and birthday of patients whose urea nitrogen (UN) is just within the borderline of passing, as specified in the Laboratory table. The query joins the Patient and Laboratory tables on the ID column and filters the results based on the UN value being between 20 and 40.\t----- bird -----\tthrombosis_prediction",
  "104": "SELECT SEX, AVG(T-BIL) as Average_T_BIL\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE T-BIL NOT BETWEEN 0.2 and 1.2\nGROUP BY SEX\nHAVING AVG(T-BIL) > 1.2;\t----- bird -----\tthrombosis_prediction",
  "105": "SELECT AVG(Birthday) as average_age\nFROM Patient\nJOIN Laboratory\nON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'Male' AND `T-CHO` > 200;\t----- bird -----\tthrombosis_prediction",
  "106": "SELECT COUNT(*)\nFROM Patient\nJOIN Laboratory\nON Patient.ID = Laboratory.ID\nWHERE Laboratory.TG > 150 AND DATEDIF(Laboratory.Date, 'now', 'year') > 50;\t----- bird -----\tthrombosis_prediction",
  "107": "SELECT COUNT(*)\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.Birthday BETWEEN '1936-01-01' AND '1956-12-31'\nAND Patient.SEX = 'Male'\nAND Laboratory.CPK > (normal_range_for_CPK); -- replace normal_range_for_CPK with the actual normal range for creatinine phosphokinase in your database.\t----- bird -----\tthrombosis_prediction",
  "108": "SELECT ID, SEX, EXTRACT('year' FROM (Birthday + '1 year' - Laboratory.Date)) AS age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE GLU NOT BETWEEN 70 AND 110 AND T_CHO BETWEEN 120 AND 200;\t----- bird -----\tthrombosis_prediction",
  "109": "SELECT P.ID, EXTRACT(YEAR FROM P.Birthday) as Age, P.Diagnosis\nFROM Patient AS P\nJOIN Examination AS E ON P.ID = E.ID\nJOIN Laboratory AS L ON P.ID = L.ID AND L.Date = E.`Examination Date`\nWHERE L.RBC < (SELECT AVG(L.RBC) FROM Laboratory AS L)\nAND P.Diagnosis IS NOT NULL\nORDER BY Age;\t----- bird -----\tthrombosis_prediction",
  "110": "SELECT ID, SEX\nFROM Patient\nINNER JOIN Examination ON Patient.ID = Examination.ID\nINNER JOIN Diagnosis ON Examination.Diagnosis = Diagnosis.Diagnosis\nINNER JOIN Laboratory ON Examination.ID = Laboratory.ID AND Examination.`Examination Date` = Laboratory.Date\nWHERE Diagnosis = 'SLE' AND HGB <= 150 AND HGB >= 120 -- Normal hemoglobin level is typically between 120 and 150 g/L\nORDER BY Birthday DESC -- Order by birthdate in descending order\nLIMIT 1;\n```\n\nThis query will join the three tables (Patient, Examination, and Laboratory) based on the ID and examination date. It will filter the results for patients diagnosed with SLE, with a normal hemoglobin level, and then order the results by birthdate in descending order to find the oldest patient. Finally, it will limit the results to the first row, which should be the oldest patient with a normal hemoglobin level.\t----- bird -----\tthrombosis_prediction",
  "111": "sql\nSELECT Patient.ID, DATEDIF(Patient.Birthday, 'now', 'year') as Age\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE HCT > 45 AND COUNT(Laboratory.ID) > 1\nGROUP BY Patient.ID, Patient.Birthday\nHAVING COUNT(DISTINCT Laboratory.Date) > 1\n```\n\nThis SQL query will return the ID and age of patients who have more than one laboratory examination with a hematocrit level exceeding the normal range (45 or higher). The query first joins the Patient and Laboratory tables based on the ID, then filters the results where the HCT is greater than 45 and there are more than one examination for each patient. Finally, it groups the results by patient ID and birthday, and filters the results again to only include patients with more than one examination date.\t----- bird -----\tthrombosis_prediction",
  "112": "SELECT COUNT(*) as LowerPlatelet, COUNT(CASE WHEN PLT > (SELECT AVG(PLT) FROM Laboratory) THEN ID END) as HigherPlatelet\nFROM Laboratory\nWHERE PLT < (SELECT AVG(PLT) - 2 * STDDEV(PLT) FROM Laboratory)\nINTERSECT\nSELECT ID FROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\n\n-- Assuming normal platelet range is average platelet level \u00b1 2 standard deviations\t----- bird -----\tthrombosis_prediction",
  "113": "SELECT Patient.ID, Patient.Sex, Patient.Birthday\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Laboratory.Date = '1984-01-01'\nAND Patient.Birthday < DATE('now', 'start of year')\nAND Laboratory.PLT BETWEEN 150000 AND 450000\n```\n\nThis query will return the ID, sex, and birthday of patients who were below 50 years old in 1984 and had a normal platelet level (between 150,000 and 450,000) for laboratory examinations taken in that year.\t----- bird -----\tthrombosis_prediction",
  "114": "SELECT COUNT(CASE WHEN SEX = 'Female' AND PT > normal_PT THEN 1 END) as female_count,\n       COUNT(CASE WHEN Birthday > '1966-01-01' AND PT > normal_PT THEN 1 END) as patient_count\nFROM Patient\nJOIN Examination ON Patient.ID = Examination.ID\nJOIN Laboratory ON Examination.ID = Laboratory.ID\nWHERE PT > normal_PT\n\n-- Assuming normal_PT is a constant or a variable with the normal prothrombin time value\t----- bird -----\tthrombosis_prediction",
  "115": "SELECT COUNT(*)\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.SEX = 'Male'\nAND Laboratory.WBC IS NULL\nAND Laboratory.FG > 200;\n```\n\nThis query counts the number of male patients who have a normal level of white blood cells (WBC IS NULL) and an abnormal fibrinogen level (FG > 200).\t----- bird -----\tthrombosis_prediction",
  "116": "SELECT COUNT(*)\nFROM Laboratory\nWHERE IGG > (normal_value_for_IgG)\nAND ID IN (\n    SELECT ID FROM Patient\n    INNER JOIN Examination ON Patient.ID = Examination.ID\n)\t----- bird -----\tthrombosis_prediction",
  "117": "SELECT COUNT(*)\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Patient.ID IN (\n    SELECT ID FROM Patient\n    JOIN Examination ON Patient.ID = Examination.ID\n    WHERE Examination.`aCL IgG` IS NULL\n)\nAND Laboratory.IGG IS NULL\nAND Symptoms IS NOT NULL;\t----- bird -----\tthrombosis_prediction",
  "118": "SELECT COUNT(P.ID)\nFROM Patient AS P\nJOIN Laboratory AS L ON P.ID = L.ID\nWHERE L.IDG A IS NULL AND L.Date > '1990-01-01';\t----- bird -----\tthrombosis_prediction",
  "119": "SELECT Diagnosis as MostCommonDisease, COUNT(*) as Count\nFROM Examination\nJOIN Patient ON Examination.ID = Patient.ID\nJOIN Laboratory ON Examination.ID = Laboratory.ID\nWHERE `aCL IgM` > (SELECT AVG(`aCL IgM`) FROM Examination JOIN Patient ON Examination.ID = Patient.ID JOIN Laboratory ON Examination.ID = Laboratory.ID)\nGROUP BY Diagnosis\nORDER BY Count DESC\nLIMIT 1;\n```\n\nThis SQLite query will find the most common diagnosis for patients with an abnormal IgM level by joining the three tables, filtering for abnormal IgM levels, grouping by diagnosis, and ordering the results in descending order of count. The LIMIT 1 at the end ensures that only the most common diagnosis is returned.\t----- bird -----\tthrombosis_prediction",
  "120": "SELECT COUNT(*)\nFROM Patient\nWHERE ID NOT IN (\n    SELECT ID\n    FROM Laboratory\n    WHERE CRP != 'normal'\n)\t----- bird -----\tthrombosis_prediction",
  "121": "SELECT COUNT(*)\nFROM Patient\nWHERE ID IN (\n    SELECT Patient.ID\n    FROM Patient\n    JOIN Laboratory ON Patient.ID = Laboratory.ID\n    WHERE Laboratory.`T-BIL` IS NOT NULL\n        AND Laboratory.T-BIL > 1.2\n        AND YEAR(Laboratory.Date) * 12 + MONTH(Laboratory.Date) < 70 * 12\n)\t----- bird -----\tthrombosis_prediction",
  "122": "SELECT COUNT(ID)\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Laboratory.RNP = 'Normal' AND Admission IS NOT NULL;\t----- bird -----\tthrombosis_prediction",
  "123": "SELECT COUNT(*)\nFROM Patient\nJOIN Examination ON Patient.ID = Examination.ID\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Examination.Thrombosis = 0 AND Laboratory.SM = 'normal' AND Examination.ID = Laboratory.ID;\t----- bird -----\tthrombosis_prediction",
  "124": "SELECT COUNT(*)\nFROM Patient\nWHERE SEX = 'Female'\nAND (Symptoms IS NULL OR Symptoms = '')\nAND `DNA-II` = 0;\t----- bird -----\tthrombosis_prediction",
  "125": "SELECT COUNT(*)\nFROM Patient\nWHERE SEX = 'Male'\nAND ID IN (\n    SELECT Patient.ID\n    FROM Patient\n    JOIN Laboratory ON Patient.ID = Laboratory.ID\n    WHERE Laboratory.`DNA` = 'Normal'\n    AND Laboratory.SSB = 'Normal'\n    AND Laboratory.`DNA-II` = 0\n)\t----- bird -----\tthrombosis_prediction",
  "126": "SELECT MIN(Birthday)\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE GLU > upper_limit_of_normal_GLU -- Replace 'upper_limit_of_normal_GLU' with the actual upper limit of normal GLU value\nAND Laboratory.Date IS NOT NULL;\t----- bird -----\tthrombosis_prediction",
  "127": "SELECT COUNT(*)\nFROM Patient\nJOIN Laboratory ON Patient.ID = Laboratory.ID\nWHERE Laboratory.CPK IS NULL AND Laboratory.PIC > 0;\n```\n\nThis SQL query counts the number of patients with a normal range of creatinine phosphokinase (CPK IS NULL) and a positive measure of degree of coagulation (PIC > 0). The results are obtained by joining the Patient and Laboratory tables on the ID column and filtering the results accordingly.\t----- bird -----\tthrombosis_prediction",
  "128": "SELECT `name` FROM `League`\nJOIN `Match` ON `League`.`id` = `Match`.`league_id`\nWHERE `season` = '2016'\nGROUP BY `League`.`id`\nORDER BY SUM(`home_team_goal` + `away_team_goal`) DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "129": "SELECT `away_team_short_name`\nFROM `Match`\nINNER JOIN `Team` ON `Match`.`away_team_api_id` = `Team`.`team_api_id`\nINNER JOIN `League` ON `Match`.`league_id` = `League`.`id`\nWHERE `country_id` = (SELECT `id` FROM `Country` WHERE `name` = 'Scotland')\nAND `season` = '2010'\nGROUP BY `away_team_short_name`\nORDER BY COUNT(*) DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "130": "SELECT `Team`.`team_short_name`, `Team_Attributes`.`buildUpPlaySpeed`\nFROM `Team`\nJOIN `Team_Attributes` ON `Team`.`team_api_id` = `Team_Attributes`.`team_api_id`\nORDER BY `Team_Attributes`.`buildUpPlaySpeed` DESC\nLIMIT 4;\t----- bird -----\teuropean_football_2",
  "131": "SELECT `League`.`name`\nFROM `Match`\nJOIN `Team` ON `Match`.`home_team_api_id` = `Team`.`team_api_id` AND `Match`.`away_team_api_id` = `Team`.`team_api_id`\nJOIN `League` ON `Team`.`league_id` = `League`.`id`\nWHERE `Match`.`season` = '2016' AND `Match`.`home_team_goal` = `away_team_goal`\nGROUP BY `League`.`name`\nORDER BY COUNT(*) DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "132": "SELECT `Player`.`player_name`, ABS(JULIANDAY('now') - STRFTIME('%s', `Player'`.`birthday`)) AS age\nFROM `Player`\nJOIN \"Player_Attributes\" ON `Player`.`player_api_id` = \"Player_Attributes\".`player_api_id`\nWHERE `Player_Attributes`.`sprint_speed` >= 97 AND `date` BETWEEN '2013-01-01' AND '2015-12-31'\nAND ABS(JULIANDAY('now') - STRFTIME('%s', `Player'`.`birthday`)) > 0;\t----- bird -----\teuropean_football_2",
  "133": "SELECT `League`.`name`, COUNT(`Match`.`id`) as `matches`\nFROM `Match`\nJOIN `League` ON `Match`.`league_id` = `League`.`id`\nGROUP BY `League`.`name`\nORDER BY `matches` DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "134": "SELECT `team_fifa_api_id`\nFROM `Team_Attributes`\nWHERE `buildUpPlaySpeed` BETWEEN 51 AND 59;\t----- bird -----\teuropean_football_2",
  "135": "SELECT `Team`.`team_long_name`\nFROM `Team`, `Team_Attributes`\nWHERE `Team`.`team_api_id` = `Team_Attributes`.`team_api_id`\nAND `Team_Attributes`.`date` = '2012'\nAND `Team_Attributes`.`buildUpPlayPassing` > AVG(`Team_Attributes`.`buildUpPlayPassing`);\t----- bird -----\teuropean_football_2",
  "136": "SELECT ROUND(COUNT(CASE WHEN preferred_foot = 'Left' THEN 1 END) / (SELECT COUNT(*) FROM Player_Attributes), 2) AS left_foot_percentage\nFROM Player_Attributes\nWHERE date BETWEEN '1987-01-01' AND '1992-12-31' AND preferred_foot IN ('Left', 'Both');\t----- bird -----\teuropean_football_2",
  "137": "SELECT AVG(long_shots) FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ahmed Samir Farag');\t----- bird -----\teuropean_football_2",
  "138": "SELECT `player_name`, AVG(`heading_accuracy`) as `average_heading_accuracy`\nFROM `Player_Attributes`\nJOIN `Player` ON `Player_Attributes`.`player_api_id` = `Player`.`player_api_id`\nWHERE `height` > 180\nGROUP BY `player_api_id`\nORDER BY `average_heading_accuracy` DESC\nLIMIT 10;\t----- bird -----\teuropean_football_2",
  "139": "SELECT `League`.`name`\nFROM `Match`\nJOIN `Team` ON `Match`.`home_team_api_id` = `Team`.`team_api_id`\nJOIN `Team` AS `away_team` ON `Match`.`away_team_api_id` = `away_team`.`team_api_id`\nJOIN `Player_Attributes` ON `Match`.`home_player_1` = `Player_Attributes`.`id`\nJOIN `Player_Attributes` AS `away_player` ON `Match`.`away_player_1` = `away_player`.`id`\nJOIN `League` ON `Match`.`league_id` = `League`.`id`\nWHERE `Match`.`season` = '2009/2010'\nAND (SUM(`home_team_goal`) > SUM(`away_team_goal`))\nGROUP BY `League`.`name`\t----- bird -----\teuropean_football_2",
  "140": "SELECT `Player`.`player_name`\nFROM `Player`\nJOIN \"Player_Attributes\" ON `Player`.`player_api_id` = \"Player_Attributes\".`player_api_id`\nWHERE EXTRACT(YEAR FROM `Player`.`birthday`) = 1970 AND EXTRACT(MONTH FROM `Player`.`birthday`) = 10\t----- bird -----\teuropean_football_2",
  "141": "SELECT `overall_rating`\nFROM \"Player_Attributes\"\nWHERE `player_name` = 'Gabriel Tamas' AND `date` LIKE '2011%';\t----- bird -----\teuropean_football_2",
  "142": "SELECT AVG(home_team_goal)\nFROM Match\nWHERE country_id = (SELECT id FROM Country WHERE name = 'Poland')\nAND season = '2010/2011';\t----- bird -----\teuropean_football_2",
  "143": "SELECT AVG(`finishing`) AS average_finishing\nFROM `Player_Attributes`\nJOIN Player ON Player_Attributes.player_api_id = Player.player_api_id\nWHERE height IN (\n    SELECT MIN(height) FROM Player\n)\nJOIN (\n    SELECT player_api_id, MAX(height) AS max_height\n    FROM Player\n    GROUP BY player_api_id\n) AS tallest_player ON Player.player_api_id = tallest_player.player_api_id\nAND Player.height = (tallest_player.max_height - 1)\nGROUP BY player_api_id\nORDER BY average_finishing DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "144": "SELECT AVG(overall_rating)\nFROM Player_Attributes\nWHERE overall_rating > 170 AND date BETWEEN '2010-01-01' AND '2015-12-31';\t----- bird -----\teuropean_football_2",
  "145": "SELECT AVG(ball_control) - AVG(CASE WHEN player_name = 'Abdou Diallo' THEN ball_control END) AS difference\nFROM Player_Attributes\nJOIN Player ON Player_Attributes.player_api_id = Player.player_api_id\nWHERE player_name = 'Aaron Appindangoye';\t----- bird -----\teuropean_football_2",
  "146": "SELECT `Player`.`player_name` as `player`, `Player`.`birthday` as `birthday`\nFROM `Player`\nWHERE `player_name` IN ('Aaron Lennon', 'Abdelaziz Barrada')\nORDER BY strftime('%s', strftime('%Y-%m-%d', `birthday`)) ASC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "147": "SELECT `player_name`, `height` FROM `Player` ORDER BY `height` DESC LIMIT 1;\t----- bird -----\teuropean_football_2",
  "148": "SELECT COUNT(*)\nFROM Player_Attributes\nWHERE preferred_foot = 'Left' AND attacking_work_rate = 'Stay Back While Attacking';\t----- bird -----\teuropean_football_2",
  "149": "SELECT COUNT(*)\nFROM Player_Attributes\nJOIN Player ON Player_Attributes.player_api_id = Player.player_api_id\nWHERE Player.birthday < '1986-01-01'\nAND Player_Attributes.attacking_work_rate = 'Low'\nAND Player_Attributes.defensive_work_rate = 'High';\t----- bird -----\teuropean_football_2",
  "150": "SELECT `player_name` FROM `Player`\nJOIN \"Player_Attributes\" ON `Player`.`player_api_id` = \"Player_Attributes`.`player_api_id`\nWHERE `volleys` > 70 AND `dribbling` > 70\t----- bird -----\teuropean_football_2",
  "151": "SELECT COUNT(*) FROM Match\nWHERE country_id = (SELECT id FROM Country WHERE name = 'Belgium')\nAND league_id = (SELECT id FROM League WHERE name = 'Jupiler League')\nAND date LIKE '2009-04-%';\t----- bird -----\teuropean_football_2",
  "152": "SELECT `name` FROM `League`\nJOIN `Match` ON `League`.`id` = `Match`.`league_id`\nWHERE `season` = '2008/2009'\nGROUP BY `name`\nORDER BY COUNT(*) DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "153": "SELECT (Ariel_Borysiuk.overall_rating - Paulin_Puel.overall_rating) as difference,\n       (Ariel_Borysiuk.overall_rating / Paulin_Puel.overall_rating) as ratio,\n       (Ariel_Borysiuk.overall_rating - Paulin_Puel.overall_rating) / Paulin_Puel.overall_rating as percentage\nFROM Player_Attributes AS Ariel_Borysiuk\nJOIN Player AS Ariel ON Ariel_Attributes.player_api_id = Ariel.player_api_id\nJOIN Player_Attributes AS Paulin_Puel ON Paulin.player_api_id = Paulin_Puel.player_api_id\nWHERE Ariel.player_name = 'Ariel Borysiuk' AND Paulin.player_name = 'Paulin Puel'\t----- bird -----\teuropean_football_2",
  "154": "SELECT AVG(overall_rating) FROM Player_Attributes WHERE player_api_id = (SELECT id FROM Player WHERE player_name = 'Pietro Marino');\t----- bird -----\teuropean_football_2",
  "155": "SELECT MAX(`chanceCreationPassing`) AS \"Highest Chance Creation Passing Score\", `chanceCreationPassingClass` AS \"Classification\"\nFROM `Team_Attributes`\nJOIN `Team` ON `Team_Attributes`.`team_api_id` = `Team`.`team_api_id`\nWHERE `Team`.`team_long_name` = 'Ajax';\t----- bird -----\teuropean_football_2",
  "156": "SELECT `player_name`, MAX(`birthday`) AS oldest_birthday\nFROM \"Player_Attributes\"\nJOIN `Player` ON `Player`.`player_api_id` = \"Player_Attributes`.`player_api_id`\nWHERE `overall_rating` = 77 AND `date` = '2016/6/23'\nGROUP BY `player_api_id`\nHAVING MAX(`birthday`);\t----- bird -----\teuropean_football_2",
  "157": "SELECT `overall_rating` FROM \"Player_Attributes\" WHERE `player_api_id` = (SELECT `player_api_id` FROM `Player` WHERE `player_name` = 'Aaron Mooy') AND `date` = '2016/2/4';\t----- bird -----\teuropean_football_2",
  "158": "SELECT `attacking_work_rate` FROM \"Player_Attributes\" WHERE `player_fifa_api_id` = (SELECT `player_fifa_api_id` FROM `Player` WHERE `player_name` = 'Francesco Migliore') AND `date` = '2015/5/1';\t----- bird -----\teuropean_football_2",
  "159": "SELECT `date` FROM \"Player_Attributes\"\nWHERE `player_api_id` = (SELECT `player_api_id` FROM `Player` WHERE `player_name` = 'Kevin Constant')\nORDER BY `crossing` DESC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "160": "SELECT `buildUpPlayPassingClass`\nFROM `Team_Attributes`\nJOIN `Team` ON `Team_Attributes`.`team_api_id` = `Team`.`team_api_id`\nWHERE `Team`.`team_short_name` = 'FC Lorient' AND `date` = '2010/02/22';\t----- bird -----\teuropean_football_2",
  "161": "SELECT `defenceAggressionClass`\nFROM `Team_Attributes`\nWHERE `team_api_id` = (\n    SELECT `team_api_id`\n    FROM `Team`\n    WHERE `team_long_name` = 'Hannover 96'\n)\nAND `date` = '2015/9/10';\t----- bird -----\teuropean_football_2",
  "162": "SELECT AVG(overall_rating) FROM \"Player_Attributes\" WHERE player_name = 'Marko Arnautovic' AND date BETWEEN '2007-02-22' AND '2016-04-21';\t----- bird -----\teuropean_football_2",
  "163": "SELECT (Player_Attributes.overall_rating - Player_Attributes.overall_rating WHERE player_api_id = (SELECT id FROM Player WHERE player_name = 'Jordan Bowery' AND date = '2013/7/12') / Player_Attributes.overall_rating WHERE player_api_id = (SELECT id FROM Player WHERE player_name = 'Landon Donovan' AND date = '2013/7/12')) * 100 AS percentage\nFROM Player_Attributes\nWHERE player_api_id IN (\n    (SELECT id FROM Player WHERE player_name = 'Jordan Bowery'),\n    (SELECT id FROM Player WHERE player_name = 'Landon Donovan')\n);\t----- bird -----\teuropean_football_2",
  "164": "SELECT `player_name` FROM `Player` WHERE `height` = (SELECT MAX(`height`) FROM `Player`)\t----- bird -----\teuropean_football_2",
  "165": "SELECT `Player`.`player_name`\nFROM `Player`, \"Player_Attributes\"\nWHERE \"Player_Attributes\".`strength` = (SELECT MAX(\"Player_Attributes\".`strength`) FROM \"Player_Attributes\")\nAND \"Player_Attributes\".`player_api_id` = `Player`.`player_api_id`\t----- bird -----\teuropean_football_2",
  "166": "SELECT `player_name` FROM `Player`\nJOIN \"Match\" ON `Player`.`player_api_id` = \"Match\".`home_player_1`\nWHERE \"Match\".`home_player_X1` > 0 OR \"Match\".`home_player_X2` > 0 OR \"Match\".`home_player_X3` > 0 OR \"Match\".`home_player_X4` > 0 OR \"Match\".`home_player_X5` > 0 OR \"Match\".`home_player_X6` > 0 OR \"Match\".`home_player_X7` > 0 OR \"Match\".`home_player_X8` > 0 OR \"Match\".`home_player_X9` > 0 OR \"Match\".`home_player_X10` > 0 OR \"Match\".`home_player_X11` > 0;\t----- bird -----\teuropean_football_2",
  "167": "SELECT `team_short_name` FROM `Team`\nJOIN `Team_Attributes` ON `Team`.`team_api_id` = `Team_Attributes`.`team_api_id`\nWHERE `chanceCreationPassing` <= 75;\t----- bird -----\teuropean_football_2",
  "168": "SELECT COUNT(*) FROM `Player` WHERE `player_name` = 'Aaron' AND STRFTIME('%Y', `birthday`) > 1990;\t----- bird -----\teuropean_football_2",
  "169": "SELECT player_Attributes.jumping\nFROM Player_Attributes\nWHERE player_api_id = 6 OR player_api_id = 23;\t----- bird -----\teuropean_football_2",
  "170": "SELECT `id`\nFROM \"Player_Attributes\"\nWHERE potential IN (SELECT MIN(potential) FROM \"Player_Attributes\") AND\n      preferred_foot = 'right'\nLIMIT 4;\t----- bird -----\teuropean_football_2",
  "171": "SELECT `player_api_id`, `preferred_foot`, MAX(`potential`, `crossing`) as max_potential_crossing\nFROM `Player_Attributes`\nWHERE `preferred_foot` = 'left'\nGROUP BY `player_api_id`, `preferred_foot`\nHAVING max_potential_crossing = MAX(max_potential_crossing)\nAND `crossing` = MAX(crossing)\nORDER BY max_potential_crossing DESC, `player_api_id` ASC\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "172": "SELECT home_team_goal, away_team_goal FROM Match WHERE date = '2008-09-24' AND league_id = (SELECT id FROM League WHERE name = 'Belgian Jupiler League')\t----- bird -----\teuropean_football_2",
  "173": "SELECT `Team_Attributes`.`buildUpPlaySpeedClass`\nFROM `Team_Attributes`\nJOIN `Team` ON `Team_Attributes`.`team_api_id` = `Team`.`team_api_id`\nWHERE `Team`.`team_long_name` = 'KSV Cercle Brugge';\t----- bird -----\teuropean_football_2",
  "174": "SELECT `player_name`, `weight`, `finishing`, `curve`\nFROM `Player`\nJOIN \"Player_Attributes\" ON `Player`.`player_api_id` = \"Player_Attributes`.`player_api_id`\nWHERE `weight` = (SELECT MAX(`weight`) FROM `Player`)\nLIMIT 1;\t----- bird -----\teuropean_football_2",
  "175": "SELECT `League`.`name`, COUNT(`Match`.`id`) as `game_count`\nFROM `Match`\nJOIN `League` ON `Match`.`league_id` = `League`.`id`\nWHERE `Match`.`season` = '2015-2016'\nGROUP BY `League`.`name`\nORDER BY `game_count` DESC\nLIMIT 4;\t----- bird -----\teuropean_football_2",
  "176": "SELECT `team_long_name` FROM `Team`\nJOIN `Match` ON `Team`.`team_api_id` = `Match`.`away_team_api_id`\nWHERE `away_team_goal` = (\n    SELECT MAX(`away_team_goal`) FROM `Match`\n)\t----- bird -----\teuropean_football_2",
  "177": "SELECT `player_name`\nFROM `Player`\nJOIN \"Player_Attributes\" ON `Player`.`player_api_id` = \"Player_Attributes`.`player_api_id`\nWHERE `overall_strength` = (SELECT MAX(`overall_strength`) FROM \"Player_Attributes\")\t----- bird -----\teuropean_football_2",
  "178": "SELECT COUNT(*) / (SELECT COUNT(*) FROM Player) as percentage\nFROM Player\nWHERE height < 180 AND overall_strength > 70\nJOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id;\t----- bird -----\teuropean_football_2",
  "179": "sql\nSELECT drivers.driverRef\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nJOIN qualifying ON results.driverId = qualifying.driverId\nWHERE results.raceId = 20 AND qualifying.q1 NOT LIKE 'Q' AND qualifying.q2 NOT LIKE 'Q' AND qualifying.q3 NOT LIKE 'Q';\t----- bird -----\tformula_1",
  "180": "SELECT surname\nFROM drivers\nJOIN results\nON drivers.driverId = results.driverId\nJOIN qualifying\nON results.raceId = qualifying.raceId AND results.driverId = qualifying.driverId\nWHERE raceId = 19 AND q2 = (\n    SELECT MAX(time)\n    FROM lapTimes\n    JOIN results\n    ON lapTimes.raceId = results.raceId AND lapTimes.driverId = results.driverId\n    WHERE raceId = 19\n)\t----- bird -----\tformula_1",
  "181": "SELECT name FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE country = 'Germany';\t----- bird -----\tformula_1",
  "182": "SELECT lat, lng FROM circuits WHERE name = 'Australian Grand Prix';\t----- bird -----\tformula_1",
  "183": "SELECT lat, lng FROM circuits WHERE name = 'Abu Dhabi Grand Prix';\t----- bird -----\tformula_1",
  "184": "SELECT q1 FROM qualifying WHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Bruno' AND surname = 'Senna') AND raceId = 354;\t----- bird -----\tformula_1",
  "185": "SELECT number\nFROM qualifying\nJOIN drivers\nON qualifying.driverId = drivers.driverId\nWHERE qualifying.raceId = 903\nAND qualifying.q3 LIKE '%01:54%';\t----- bird -----\tformula_1",
  "186": "SELECT COUNT(*)\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Bahrain Grand Prix' AND year = 2007)\nAND position IS NULL OR position = 0;\t----- bird -----\tformula_1",
  "187": "SELECT drivers.forename, drivers.surname, drivers.dob\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nWHERE results.raceId = 592 AND results.position <> 0\nORDER BY drivers.dob DESC\nLIMIT 1;\t----- bird -----\tformula_1",
  "188": "sql\nSELECT drivers.url\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nJOIN lapTimes ON drivers.driverId = lapTimes.driverId AND lapTimes.raceId = results.raceId AND lapTimes.lap = 1\nWHERE results.raceId = 161 AND lapTimes.time = '0:01:27'\t----- bird -----\tformula_1",
  "189": "SELECT circuits.lat, circuits.lng\nFROM circuits\nWHERE circuits.name = 'Malaysian Grand Prix';\t----- bird -----\tformula_1",
  "190": "SELECT url FROM constructors WHERE constructorId = (\n    SELECT constructorId FROM constructorResults\n    WHERE raceId = 9 AND points IN (\n        SELECT MAX(points) FROM constructorResults WHERE raceId = 9\n    )\n)\t----- bird -----\tformula_1",
  "191": "SELECT driverRef\nFROM qualifying\nJOIN drivers ON qualifying.driverId = drivers.driverId\nWHERE raceId = 45 AND q3 = '0:01:33';\t----- bird -----\tformula_1",
  "192": "SELECT seasons.year, races.name, races.date\nFROM seasons\nJOIN races ON seasons.year = races.year\nWHERE races.raceId = 901;\t----- bird -----\tformula_1",
  "193": "SELECT MIN(d.dob) as youngest_dob, d.forename, d.surname\nFROM drivers d\nJOIN results r ON d.driverId = r.driverId\nWHERE r.raceId = 872 AND r.position <> 0;\t----- bird -----\tformula_1",
  "194": "SELECT nationality FROM drivers\nJOIN results ON drivers.driverId = results.driverId\nWHERE results.fastestLapSpeed = (\n    SELECT MAX(results.fastestLapSpeed) FROM results\n)\t----- bird -----\tformula_1",
  "195": "SELECT\n    (fastest_lap_speed_853 - fastest_lap_speed_next_race) / fastest_lap_speed_853 AS percent_difference\nFROM\n    (\n        SELECT\n            races.raceId,\n            drivers.driverId,\n            MIN(lapTimes.time) AS fastest_lap_time_853,\n            EXTRACT(EPOCH FROM JULIANDAY(MIN(lapTimes.time)) - JULIANDAY(MIN(lapTimes.time) + INTERVAL '1 race'))) AS milliseconds_between_races,\n            lapTimes.driverId AS next_race_driverId,\n            MAX(lapTimes.time) AS fastest_lap_time_next_race,\n            lapTimes.driverId AS fastest_lap_driverId_next_race\n        FROM\n            races\n        JOIN\n            drivers ON races.raceId = drivers.raceId\n        JOIN\n            lapTimes ON races.raceId = lapTimes.raceId\n        WHERE\n            races.raceId = 853\n        GROUP BY\n            races.raceId, drivers.driverId\n        UNION ALL\n        SELECT\n            races.raceId,\n            next_race_driverId,\n            MAX(lapTimes.time) AS fastest_lap_time_next_race,\n            lapTimes.driverId AS fastest_lap_driverId_next_race\n        FROM\n            races\n        JOIN\n            drivers ON races.raceId = drivers.raceId\n        JOIN\n            lapTimes ON races.raceId = lapTimes.raceId\n        JOIN\n            (\n                SELECT\n                    races.raceId,\n                    drivers.driverId,\n                    MIN(lapTimes.time) AS fastest_lap_time_853,\n                    EXTRACT(EPOCH FROM JULIANDAY(MIN(lapTimes.time)) - JULIANDAY(MIN(lapTimes.time) + INTERVAL '1 race'))) AS milliseconds_between_races\n                FROM\n                    races\n                JOIN\n                    drivers ON races.raceId = drivers.raceId\n                JOIN\n                    lapTimes ON races.raceId = lapTimes.raceId\n                WHERE\n                    races.raceId = 853\n                GROUP BY\n                    races.raceId, drivers.driverId\n            ) AS previous_race\n        WHERE\n            races.raceId = previous_race.raceId + 1\n        GROUP BY\n            races.raceId, next_race_driverId\n    ) AS race_data\nJOIN\n    drivers ON race_data.next_race_driverId = drivers.driverId\nJOIN\n    (\n        SELECT\n            drivers.driverId,\n            MAX(lapTimes.time) AS fastest_lap_time\n        FROM\n            drivers\n        JOIN\n            lapTimes ON drivers.driverId = lapTimes.driverId\n        WHERE\n            drivers.driverRef = 'paul_di_resta'\n        GROUP BY\n            drivers.driverId\n    ) AS paul_di_resta_fastest_lap ON paul_di_resta_fastest_lap.driverId = race_data.driverId\nWHERE\n    race_data.driverId = paul_di_resta_fastest_lap.driverId\t----- bird -----\tformula_1",
  "196": "SELECT\n    AVG(completionRate) as average_completion_rate\nFROM (\n    SELECT\n        driverId,\n        COUNT(raceId) as races_participated,\n        SUM(CASE WHEN position != 'Retired' THEN 1 ELSE 0 END) as races_completed\n    FROM\n        results\n    JOIN drivers ON results.driverId = drivers.driverId\n    WHERE\n        results.raceId IN (\n            SELECT raceId FROM races WHERE date = '1983-07-16'\n        )\n    GROUP BY driverId\n) as completion_rates;\t----- bird -----\tformula_1",
  "197": "SELECT name\nFROM races\nWHERE year = (SELECT MIN(year) FROM races) AND MONTH(date) = (SELECT MIN(MONTH(date)) FROM races);\t----- bird -----\tformula_1",
  "198": "SELECT forename || ' ' || surname as full_name, driverId\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nGROUP BY driverId\nORDER BY SUM(points) DESC\nLIMIT 1;\n```\n\nThis SQL query will return the full name of the driver with the most points scored. The query joins the `drivers` and `results` tables on the `driverId` column, groups the results by `driverId`, sums the points for each driver, orders the results in descending order, and limits the result set to the top 1 row (the driver with the most points).\t----- bird -----\tformula_1",
  "199": "SELECT drivers.forename, drivers.surname, races.name\nFROM lapTimes\nJOIN drivers ON lapTimes.driverId = drivers.driverId\nJOIN races ON lapTimes.raceId = races.raceId\nWHERE lapTimes.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes)\t----- bird -----\tformula_1",
  "200": "SELECT AVG(time)\nFROM lapTimes\nWHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton')\nAND raceId = (SELECT raceId FROM races WHERE name = 'Malaysian Grand Prix' AND year = 2009)\t----- bird -----\tformula_1",
  "201": "sql\nSELECT\n    round(\n        COUNT(d.driverId) * 100.0 /\n        (\n            SELECT COUNT(*) FROM races r\n            JOIN drivers d ON r.raceId = d.raceId\n            WHERE r.year >= 2010 AND d.forename = 'Lewis' AND d.surname = 'Hamilton' AND r.circuitId = (\n                SELECT circuitId FROM circuits WHERE name = 'Albert Park'\n            )\n        )\n    ) AS percentage\nFROM races r\nJOIN drivers d ON r.raceId = d.raceId\nWHERE r.year >= 2010 AND d.forename = 'Lewis' AND d.surname = 'Hamilton';\t----- bird -----\tformula_1",
  "202": "SELECT drivers.forename, drivers.surname, drivers.nationality, MAX(results.points) as max_points\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nWHERE results.position = 1\nGROUP BY drivers.driverId\nORDER BY max_points DESC, drivers.surname ASC, drivers.forename ASC\nLIMIT 1;\n```\n\nThis query will return the name, nationality, and maximum points of the driver with the most wins.\t----- bird -----\tformula_1",
  "203": "SELECT MIN(d.dob), d.forename, d.surname\nFROM drivers d\nJOIN (\n    SELECT driverId\n    FROM drivers\n    WHERE nationality = 'Japanese'\n) j ON d.driverId = j.driverId\nWHERE d.nationality = 'Japanese'\t----- bird -----\tformula_1",
  "204": "SELECT races.name, circuits.name AS circuitName, circuits.location\nFROM races\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE races.year = 2005 AND races.month = 9\t----- bird -----\tformula_1",
  "205": "SELECT raceId\nFROM results\nWHERE driverId = (SELECT driverId FROM drivers WHERE forename = 'Alex' AND surname = 'Yoong')\nAND number < 20;\t----- bird -----\tformula_1",
  "206": "SELECT race.name, race.year\nFROM races race\nJOIN results result ON race.raceId = result.raceId\nJOIN drivers driver ON result.driverId = driver.driverId\nWHERE driver.driverRef = 'schumacher, michael'\nAND result.fastestLap = 1;\t----- bird -----\tformula_1",
  "207": "sql\nSELECT races.year, races.round, drivers.driverId, results.points\nFROM races\nJOIN results ON races.raceId = results.raceId\nJOIN drivers ON results.driverId = drivers.driverId\nWHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\nORDER BY races.year ASC, races.round ASC\nLIMIT 1;\n```\n\nThis query will find the first race of Lewis Hamilton by joining the `races`, `results`, and `drivers` tables based on their relationships. It filters the results to only include rows where the driver's first name is 'Lewis' and the last name is 'Hamilton'. The `ORDER BY` clause sorts the results by year and round in ascending order, and the `LIMIT 1` clause returns only the first row, which corresponds to Lewis Hamilton's first race. The query also selects the year, round, driver ID, and points for the first race.\t----- bird -----\tformula_1",
  "208": "SELECT ROUND(COUNT(*) * 100.0 / (\n    SELECT COUNT(*) FROM races\n    WHERE location LIKE 'Europe' AND country LIKE 'Germany'\n), 2) AS percentage\nFROM races\nWHERE location LIKE 'Europe' AND country LIKE 'Germany' AND lat BETWEEN 50.0 AND 60.0 AND lng BETWEEN 6.0 AND 15.0\n```\n\nThis query calculates the percentage of European Grand Prix races that were hosted in Germany by counting the number of races with a location in Europe, country as Germany, and latitude and longitude within the approximate range of Germany, and then dividing that count by the total number of European Grand Prix races. The approximate range for Germany is provided as latitude between 50.0 and 60.0 and longitude between 6.0 and 15.0.\t----- bird -----\tformula_1",
  "209": "SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit'\t----- bird -----\tformula_1",
  "210": "SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';\t----- bird -----\tformula_1",
  "211": "SELECT nationality, MIN(dob) AS min_dob\nFROM drivers\nGROUP BY nationality\nORDER BY min_dob ASC\nLIMIT 1;\n\nThis SQL query will return the nationality of the oldest driver from the drivers table.\t----- bird -----\tformula_1",
  "212": "SELECT drivers.driverRef\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nJOIN races ON races.raceId = results.raceId\nWHERE races.year = 2007 AND races.name = 'Canadian Grand Prix' AND results.position = 1;\t----- bird -----\tformula_1",
  "213": "SELECT raceId, MAX(position) as highest_rank\nFROM results\nJOIN drivers ON results.driverId = drivers.driverId\nWHERE drivers.forename = 'Lewis' AND surname = 'Hamilton'\nGROUP BY raceId;\t----- bird -----\tformula_1",
  "214": "SELECT fastestLapSpeed\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE year = 2009 AND name = 'Spanish Grand Prix')\nORDER BY fastestLapSpeed DESC\nLIMIT 1;\t----- bird -----\tformula_1",
  "215": "SELECT rank\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix' AND year = 2008)\nAND driverId = (SELECT driverId FROM drivers WHERE surname = 'Hamilton' AND forename = 'Lewis');\t----- bird -----\tformula_1",
  "216": "SELECT time FROM results\nWHERE raceId = (\n    SELECT raceId FROM races\n    INNER JOIN seasons ON races.year = seasons.year\n    WHERE seasons.year = 2008 AND races.name = 'AustChineseralian Grand Prix'\n) AND position = 2;\t----- bird -----\tformula_1",
  "217": "SELECT COUNT(*)\nFROM drivers\nWHERE driverId IN (\n    SELECT driverId\n    FROM results\n    WHERE raceId = (\n        SELECT raceId\n        FROM races\n        WHERE name = '2008 Chinese Grand Prix' AND year = 2008\n    ) AND position <= (\n        SELECT COUNT(*)\n        FROM results\n        WHERE raceId = (\n            SELECT raceId\n            FROM races\n            WHERE name = '2008 Chinese Grand Prix' AND year = 2008\n        )\n    )\n)\t----- bird -----\tformula_1",
  "218": "SELECT\n    (\n        (\n            (\n                SELECT fastestLapTime FROM results\n                WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') AND driverId = (\n                    SELECT driverId FROM driverStandings\n                    WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') AND position = (\n                        SELECT COUNT(*) FROM driverStandings WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix')\n                    )\n                )\n            ) - (\n                SELECT fastestLapTime FROM results\n                WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') AND driverId = (\n                    SELECT driverId FROM driverStandings\n                    WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') AND position = (\n                        SELECT COUNT(*) FROM driverStandings WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') + 1\n                    )\n                )\n            )\n        ) / (\n            SELECT fastestLapTime FROM results\n            WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') AND driverId = (\n                SELECT driverId FROM driverStandings\n                WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix') AND position = (\n                    SELECT COUNT(*) FROM driverStandings WHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix')\n                )\n            )\n        )\n    ) * 100\nFROM results\nWHERE raceId = (SELECT raceId FROM races WHERE name = '2008 Australian Grand Prix')\t----- bird -----\tformula_1",
  "219": "SELECT COUNT(*) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia';\t----- bird -----\tformula_1",
  "220": "SELECT MAX(points) FROM constructorStandings WHERE nationality = 'British';\t----- bird -----\tformula_1",
  "221": "SELECT name FROM constructors\nWHERE constructorId IN (\n    SELECT constructorId FROM constructorResults\n    WHERE raceId = 291 AND points = 0\n)\t----- bird -----\tformula_1",
  "222": "SELECT COUNT(*)\nFROM constructorStandings cs\nJOIN constructors c ON cs.constructorId = c.constructorId\nJOIN drivers d ON c.constructorRef = d.driverRef\nJOIN races r ON cs.raceId = r.raceId\nWHERE c.nationality = 'Japan' AND cs.points = 0 AND r.year = (SELECT MAX(year) FROM races)\nAND r.year - 1 = (SELECT MAX(year) FROM races WHERE year < (SELECT MAX(year) FROM races))\t----- bird -----\tformula_1",
  "223": "SELECT AVG(laps / (SELECT COUNT(*) FROM lapTimes WHERE raceId IN (\n    SELECT raceId FROM races WHERE year BETWEEN 2007 AND 2009\n))) AS completion_percentage\nFROM lapTimes\nJOIN drivers ON lapTimes.driverId = drivers.driverId\nWHERE drivers.nationality = 'Japan'\t----- bird -----\tformula_1",
  "224": "SELECT AVG(time_in_seconds) as average_time\nFROM (\n    SELECT strftime('%s', strftime('%s', time, '1970-01-01')) as time_in_seconds\n    FROM results\n    JOIN drivers ON results.driverId = drivers.driverId\n    JOIN constructors ON results.constructorId = constructors.constructorId\n    JOIN seasons ON results.raceId = seasons.year\n    WHERE constructors.name IN (\n        SELECT name\n        FROM constructors\n        JOIN driverStandings ON constructors.constructorId = driverStandings.constructorId\n        JOIN races ON driverStandings.raceId = races.raceId\n        JOIN drivers ON driverStandings.driverId = drivers.driverId\n        GROUP BY constructors.name\n        HAVING COUNT(*) = (SELECT COUNT(*) FROM races WHERE year < seasons.year)\n    )\n    AND seasons.year < 1975\n)\t----- bird -----\tformula_1",
  "225": "SELECT fastestLap FROM results\nJOIN drivers ON results.driverId = drivers.driverId\nJOIN constructors ON results.constructorId = constructors.constructorId\nWHERE year = 2009 AND position = 1 AND drivers.surname = (\n    SELECT surname FROM drivers\n    JOIN constructorResults cr ON drivers.driverId = cr.driverId\n    JOIN constructorStandings cs ON cr.constructorId = cs.constructorId\n    WHERE year = 2009 AND cs.position = 1\n)\t----- bird -----\tformula_1",
  "226": "SELECT AVG(fastestLapSpeed) FROM results WHERE raceId = (SELECT raceId FROM races WHERE year = 2009 AND name = 'Spanish Grand Prix');\t----- bird -----\tformula_1",
  "227": "SELECT COUNT(*) as total_drivers,\n       COUNT(CASE WHEN drivers.dob < '1985-01-01' AND races.lap > 50 THEN drivers.driverId END) as drivers_with_lap_over_50\nFROM drivers\nJOIN races ON drivers.driverId = races.driverId\nWHERE races.year BETWEEN 2000 AND 2005 AND drivers.dob < '1985-01-01'\n\nSELECT (COUNT(*) - COUNT(CASE WHEN drivers.dob < '1985-01-01' AND races.lap > 50 THEN drivers.driverId END)) / COUNT(*) as percentage\nFROM (\n    SELECT driverId FROM drivers\n    WHERE dob < '1985-01-01'\n    UNION ALL\n    SELECT driverId FROM drivers\n    WHERE dob < '1985-01-01' AND races.lap > 50\n) AS drivers\nJOIN races ON drivers.driverId = races.driverId\nWHERE races.year BETWEEN 2000 AND 2005\t----- bird -----\tformula_1",
  "228": "SELECT COUNT(*)\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nJOIN races ON results.raceId = races.raceId\nJOIN circuits ON races.circuitId = circuits.circuitId\nWHERE drivers.nationality = 'French'\nAND results.milliseconds < (2 * 60 * 60 * 1000)\nAND circuits.country = 'France';\t----- bird -----\tformula_1",
  "229": "SELECT driverId, forename, surname FROM drivers WHERE nationality = 'American'\t----- bird -----\tformula_1",
  "230": "sql\nSELECT driverId, COUNT(*) as nationalityCount\nFROM drivers\nWHERE nationality = 'Netherlands'\nGROUP BY driverId\nORDER BY dob ASC\nLIMIT 3;\n\nSELECT driverId\nFROM (\n    SELECT driverId, ROW_NUMBER() OVER (ORDER BY dob ASC) as rowNumber, dob\n    FROM drivers\n    WHERE nationality IN (\n        SELECT driverId\n        FROM drivers\n        WHERE nationality = 'Netherlands'\n        GROUP BY driverId\n        ORDER BY dob ASC\n        LIMIT 3\n    )\n) as subQuery\nWHERE rowNumber <= 3;\t----- bird -----\tformula_1",
  "231": "SELECT drivers.driverRef\nFROM drivers\nJOIN seasons ON drivers.dob <= (SELECT min(year) FROM seasons)\nJOIN constructors ON drivers.constructorId = constructors.constructorId\nWHERE drivers.nationality = 'Germany';\t----- bird -----\tformula_1",
  "232": "SELECT driverId, code\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nWHERE drivers.dob = '1971-01-01'\nAND results.fastestLap = 1;\t----- bird -----\tformula_1",
  "233": "SELECT SUM(CASE WHEN position = 0 THEN 1 ELSE 0 END) as disqualified_finishers\nFROM results\nWHERE raceId >= 50 AND raceId <= 100 AND position != NULL\t----- bird -----\tformula_1",
  "234": "SELECT circuitId, name, location, lat, lng FROM circuits WHERE country = 'Austria' AND circuitRef IN (\n    SELECT circuitRef FROM (\n        SELECT circuitRef FROM circuits WHERE country = 'Austria'\n        GROUP BY circuitRef\n        HAVING COUNT(*) > 1\n    )\n);\t----- bird -----\tformula_1",
  "235": "sql\nSELECT races.year, races.name, races.date, races.time\nFROM races\nJOIN drivers ON races.raceId = drivers.raceId\nJOIN results ON races.raceId = results.raceId AND drivers.driverId = results.driverId\nWHERE results.driverId = (\n    SELECT driverId\n    FROM drivers\n    ORDER BY dob ASC\n    LIMIT 1\n)\nORDER BY races.date ASC\nLIMIT 1;\n```\n\nThis SQL query will find the race where the youngest driver participated for the first time. It first finds the ID of the youngest driver by ordering all drivers by their birthdate in ascending order and selecting the first one. Then it joins the races, drivers, and results tables to find the race where this youngest driver participated. Finally, it orders the results by date in ascending order and selects the first one, which is the race with the youngest driver's first qualifying race.\t----- bird -----\tformula_1",
  "236": "SELECT drivers.forename, drivers.surname, AVG(pitStops.duration) as average_duration\nFROM drivers\nJOIN pitStops ON drivers.driverId = pitStops.driverId\nWHERE drivers.nationality = 'Germany' AND drivers.dob BETWEEN '1980-01-01' AND '1985-12-31'\nGROUP BY drivers.driverId\nORDER BY average_duration ASC\nLIMIT 3;\t----- bird -----\tformula_1",
  "237": "SELECT drivers.surname, results.time\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nJOIN races ON results.raceId = races.raceId\nWHERE races.name = 'Canadian Grand Prix' AND races.year = 2008 AND results.position = 1;\t----- bird -----\tformula_1",
  "238": "SELECT constructors.url\nFROM constructors\nJOIN constructorResults cr ON constructors.constructorId = cr.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.year = 2009 AND r.name = 'Singapore Grand Prix' AND cr.points = (SELECT MAX(points) FROM constructorResults WHERE year = 2009 AND raceId = (SELECT raceId FROM races WHERE name = 'Singapore Grand Prix'));\t----- bird -----\tformula_1",
  "239": "SELECT power_name FROM superpower JOIN hero_power ON superpower.id = hero_power.power_id WHERE hero_power.hero_id = (SELECT id FROM superhero WHERE superhero_name = '3-D Man');\t----- bird -----\tsuperhero",
  "240": "SELECT constructorName, constructorNationality, SUM(points) as totalPoints\nFROM constructors\nJOIN constructorResults cr ON constructors.constructorId = cr.constructorId\nJOIN races r ON cr.raceId = r.raceId\nWHERE r.year BETWEEN 1980 AND 2010 AND r.name = 'Monaco Grand Prix'\nGROUP BY constructors.constructorId, constructors.constructorName, constructors.constructorNationality\nORDER BY totalPoints DESC\nLIMIT 1;\t----- bird -----\tformula_1",
  "241": "SELECT forename || ' ' || surname\nFROM drivers\nJOIN qualifying ON drivers.driverId = qualifying.driverId\nJOIN races ON qualifying.raceId = races.raceId\nWHERE races.year = 2008 AND races.circuitRef = 'Marina Bay Street Circuit' AND qualifying.round = 3 AND qualifying.position = 1;\t----- bird -----\tformula_1",
  "242": "SELECT forename || ' ' || surname AS fullName, nationality, races.name AS raceName\nFROM drivers\nJOIN results ON drivers.driverId = results.driverId\nJOIN races ON races.raceId = results.raceId\nWHERE dob = (SELECT MIN(dob) FROM drivers)\t----- bird -----\tformula_1",
  "243": "SELECT MAX(accidents) FROM accidents_table\nWHERE raceId = (SELECT raceId FROM races WHERE name = 'Canadian Grand Prix');\t----- bird -----\tformula_1",
  "244": "sql\nSELECT forename || ' ' || surname as FullName, MIN(milliseconds) as ShortestLapTime\nFROM results\nJOIN drivers ON results.driverId = drivers.driverId\nWHERE results.raceId IN (\n    SELECT raceId FROM races\n)\nGROUP BY driverId\nORDER BY ShortestLapTime ASC\nLIMIT 20;\n```\n\nThis SQL query will return the full names of the top 20 drivers who have created the shortest lap time ever record in a Formula_1 race, along with their shortest lap time. The query first joins the `results` table with the `drivers` table on the `driverId` column. It then filters the races by including only those that have a valid race ID. After that, it groups the results by `driverId` and orders them by the shortest lap time in ascending order. Finally, it limits the results to the top 20.\t----- bird -----\tformula_1",
  "245": "SELECT c.name, l.driverId, l.time, l.milliseconds\nFROM races r\nJOIN circuits c ON r.circuitId = c.circuitId\nJOIN lapTimes l ON r.raceId = l.raceId\nWHERE c.country = 'Italy';\t----- bird -----\tformula_1",
  "246": "SELECT COUNT(*)\nFROM superhero\nJOIN hero_power ON superhero.id = hero_power.hero_id\nJOIN superpower ON hero_power.power_id = superpower.id\nWHERE superhero.height_cm > 200 AND superpower.power_name = 'Super Strength'\t----- bird -----\tsuperhero",
  "247": "SELECT COUNT(*)\nFROM superhero\nJOIN hero_power ON superhero.id = hero_power.hero_id\nJOIN superpower ON hero_power.power_id = superpower.id\nWHERE superhero.eye_colour_id = (SELECT id FROM colour WHERE colour = 'blue')\nAND superpower.power_name = 'Agility';\t----- bird -----\tsuperhero",
  "248": "SELECT superhero_name\nFROM superhero\nJOIN colour ON superhero.eye_colour_id = colour.id\nJOIN colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id\nWHERE colour.colour = 'blue' AND hair_colour.colour = 'blond';\t----- bird -----\tsuperhero",
  "249": "SELECT superhero.id, superhero.superhero_name\nFROM superhero\nJOIN publisher\nON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel Comics'\nORDER BY superhero.height_cm DESC;\t----- bird -----\tsuperhero",
  "250": "SELECT superhero.superhero_name, colour.colour\nFROM superhero\nJOIN hero_attribute ON superhero.id = hero_attribute.hero_id\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nJOIN colour ON hero_attribute.attribute_id = (\n    SELECT id FROM attribute WHERE attribute_name = 'eye_colour'\n)\nJOIN superhero s ON s.id = superhero.id\nLEFT JOIN (\n    SELECT superhero_id, COUNT(*) as count\n    FROM hero_attribute\n    JOIN attribute ON hero_attribute.attribute_id = attribute.id\n    WHERE attribute_name = 'eye_colour'\n    GROUP BY superhero_id\n) as eye_colour_count ON s.id = eye_colour_count.superhero_id\nWHERE s.publisher_id = (\n    SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics'\n)\nGROUP BY superhero.id, colour.colour\nORDER BY eye_colour_count.count DESC, colour.colour ASC;\n```\n\nThis SQL query will join the necessary tables, filter for Marvel Comics superheroes, group by superhero and eye color, and order the results by the count of each eye color within each superhero, starting with the most common eye color.\t----- bird -----\tsuperhero",
  "251": "SELECT superhero.superhero_name\nFROM superhero\nJOIN hero_power ON superhero.id = hero_power.hero_id\nJOIN superpower ON hero_power.power_id = superpower.id\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE superpower.power_name = 'Super Strength' AND publisher.publisher_name = 'Marvel Comics'\t----- bird -----\tsuperhero",
  "252": "SELECT publisher_name, MIN(weight_kg) as min_weight\nFROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nGROUP BY publisher_name\nORDER BY min_weight;\t----- bird -----\tsuperhero",
  "253": "SELECT COUNT(*) FROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE superhero.eye_colour_id = (SELECT id FROM colour WHERE colour = 'Gold')\nAND publisher.publisher_name = 'Marvel Comics';\t----- bird -----\tsuperhero",
  "254": "SELECT superhero.id, superhero.superhero_name\nFROM superhero\nJOIN (\n    SELECT hero_id, MIN(attribute_value) as min_value\n    FROM hero_attribute\n    GROUP BY hero_id\n) as scores\nON superhero.id = scores.hero_id\nWHERE attribute_id = (\n    SELECT id FROM attribute WHERE attribute_name = 'IQ'\n) AND scores.min_value = (\n    SELECT MIN(min_value) FROM (\n        SELECT hero_id, MIN(attribute_value) as min_value\n        FROM hero_attribute\n        GROUP BY hero_id\n    ) as scores\n);\t----- bird -----\tsuperhero",
  "255": "SELECT race_id\nFROM superhero\nWHERE superhero_name = 'Copycat';\t----- bird -----\tsuperhero",
  "256": "SELECT superhero.id, superhero.superhero_name\nFROM superhero\nJOIN hero_attribute ON superhero.id = hero_attribute.hero_id\nWHERE hero_attribute.attribute_id = (\n    SELECT id FROM attribute WHERE attribute_name = 'durability'\n) AND hero_attribute.attribute_value < 50;\t----- bird -----\tsuperhero",
  "257": "SELECT superhero_name\nFROM superhero\nJOIN hero_power\nON superhero.id = hero_power.hero_id\nJOIN superpower\nON hero_power.power_id = superpower.id\nWHERE superpower.power_name = 'death touch';\t----- bird -----\tsuperhero",
  "258": "SELECT COUNT(*)\nFROM superhero\nJOIN hero_attribute ON superhero.id = hero_attribute.hero_id\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE superhero.gender_id = (SELECT id FROM gender WHERE gender = 'Female')\nAND attribute.attribute_name = 'Strength'\nAND hero_attribute.attribute_value = 100\t----- bird -----\tsuperhero",
  "259": "SELECT COUNT(*) as total_self_interested, SUM(CASE WHEN publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics') THEN 1 ELSE 0 END) as marvel_self_interested\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nWHERE alignment.alignment = 'Self-Interest' OR alignment.alignment = 'Moral Code';\n```\n\nThis SQL query calculates the total number of superheroes who act in their own self-interest or make decisions based on their own moral code, and also counts the number of those superheroes who were published by Marvel Comics. The result will be presented as two values: the total number of self-interested superheroes and the number of self-interested superheroes published by Marvel Comics.\t----- bird -----\tsuperhero",
  "260": "SELECT COUNT(superhero.id) as dc_superheroes FROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'DC';\n\nSELECT COUNT(superhero.id) as marvel_superheroes FROM superhero\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE publisher.publisher_name = 'Marvel';\n\nSELECT (marvel_superheroes - dc_superheroes) as difference;\t----- bird -----\tsuperhero",
  "261": "SELECT publisher_id FROM publisher WHERE publisher_name = 'Star Trek';\t----- bird -----\tsuperhero",
  "262": "SELECT COUNT(*) FROM superhero WHERE full_name IS NULL;\t----- bird -----\tsuperhero",
  "263": "SELECT AVG(weight_kg) FROM superhero\nJOIN gender ON superhero.gender_id = gender.id\nWHERE gender.gender = 'female'\t----- bird -----\tsuperhero",
  "264": "SELECT power_name\nFROM superpower\nJOIN hero_power ON superpower.id = hero_power.power_id\nJOIN superhero ON hero_power.hero_id = superhero.id\nWHERE superhero.gender_id = (SELECT id FROM gender WHERE gender = 'Male')\nGROUP BY power_name\nHAVING COUNT(*) > 0;\t----- bird -----\tsuperhero",
  "265": "SELECT superhero_name\nFROM superhero\nWHERE height_cm BETWEEN 170 AND 190\nAND eye_colour_id IS NULL;\t----- bird -----\tsuperhero",
  "266": "SELECT hair_colour_id\nFROM superhero\nWHERE height_cm = 185 AND superhero.type = 'human';\n\nThen, use another query to get the hair colour name:\n\nSELECT colour.colour\nFROM colour\nJOIN superhero ON superhero.hair_colour_id = colour.id\nWHERE superhero.id = (SELECT superhero.id FROM superhero WHERE height_cm = 185 AND superhero.type = 'human');\t----- bird -----\tsuperhero",
  "267": "SELECT COUNT(*) as marvel_heroes, SUM(CASE WHEN publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics') THEN 1 ELSE 0 END) as marvel_count\nFROM superhero\nWHERE height_cm BETWEEN 150 AND 180\n\nSELECT (marvel_count / COUNT(*)) * 100 as percentage\nFROM (\n    SELECT SUM(CASE WHEN publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics') THEN 1 ELSE 0 END) as marvel_count\n    FROM superhero\n    WHERE height_cm BETWEEN 150 AND 180\n) as subquery\t----- bird -----\tsuperhero",
  "268": "SELECT superhero_name\nFROM superhero\nJOIN (\n    SELECT AVG(weight_kg) as avg_weight, COUNT(*) as total_superheroes\n    FROM superhero\n) as avg_weight_data\nON superhero.gender_id = 1\nWHERE superhero.weight_kg > (avg_weight_data.avg_weight * 0.79)\t----- bird -----\tsuperhero",
  "269": "SELECT power_name FROM superpower\nJOIN hero_power ON superpower.id = hero_power.power_id\nWHERE hero_power.hero_id = 1;\t----- bird -----\tsuperhero",
  "270": "SELECT COUNT(*) FROM hero_power HP\nJOIN superpower SP ON HP.power_id = SP.id\nWHERE SP.power_name = 'stealth'\nAND HP.hero_id IN (\n    SELECT id FROM superhero\n)\t----- bird -----\tsuperhero",
  "271": "SELECT full_name\nFROM superhero\nJOIN hero_attribute ON superhero.id = hero_attribute.hero_id\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE attribute.attribute_name = 'strength'\nORDER BY hero_attribute.attribute_value DESC\nLIMIT 1;\t----- bird -----\tsuperhero",
  "272": "SELECT superhero.id, superhero.superhero_name\nFROM superhero\nJOIN hero_power ON superhero.id = hero_power.hero_id\nJOIN superpower ON hero_power.power_id = superpower.id\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE superpower.power_name = 'Durability' AND publisher.publisher_name = 'Dark Horse Comics'\nGROUP BY superhero.id, superhero.superhero_name\nORDER BY COUNT(*) DESC\nLIMIT 1;\t----- bird -----\tsuperhero",
  "273": "SELECT superhero.hair_colour_id, superhero.eye_colour_id, superhero.skin_colour_id\nFROM superhero\nJOIN gender ON superhero.gender_id = gender.id\nJOIN publisher ON superhero.publisher_id = publisher.id\nWHERE gender.gender = 'Female' AND publisher.publisher_name = 'Dark Horse Comics'\t----- bird -----\tsuperhero",
  "274": "SELECT superhero.publisher_name\nFROM superhero\nWHERE superhero.eye_colour_id = superhero.hair_colour_id\nAND superhero.eye_colour_id = superhero.skin_colour_id;\t----- bird -----\tsuperhero",
  "275": "SELECT ROUND(100 * COUNT(CASE WHEN s.gender_id = (SELECT id FROM gender WHERE gender = 'Female') AND hc.colour_id = (SELECT id FROM colour WHERE colour = 'Blue') THEN s.id END) /\n                      (SELECT COUNT(*) FROM superhero WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female')), 2) AS percentage\nFROM superhero s\nJOIN hero_colour hc ON s.hair_colour_id = hc.id\nJOIN superhero_attribute sa ON s.id = sa.hero_id\nJOIN attribute a ON sa.attribute_id = a.id AND a.attribute_name = 'Gender'\nJOIN gender g ON s.gender_id = g.id\nJOIN colour c ON hc.colour_id = c.id AND c.colour = 'Blue';\t----- bird -----\tsuperhero",
  "276": "SELECT COUNT(*) FROM hero_power WHERE hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Amazo');\t----- bird -----\tsuperhero",
  "277": "SELECT superhero.height_cm\nFROM superhero\nJOIN colour ON superhero.eye_colour_id = colour.id\nWHERE colour.colour = 'amber';\t----- bird -----\tsuperhero",
  "278": "SELECT superhero.superhero_name\nFROM superhero\nJOIN colour ON superhero.eye_colour_id = colour.id AND superhero.hair_colour_id = colour.id\nWHERE colour.colour = 'black' AND colour.colour = 'black';\t----- bird -----\tsuperhero",
  "279": "SELECT superhero_name\nFROM superhero\nJOIN alignment ON superhero.alignment_id = alignment.id\nWHERE alignment.alignment = 'Neutral'\nAND superhero.superhero_name IS NOT NULL;\t----- bird -----\tsuperhero",
  "280": "SELECT superhero.id\nFROM superhero\nJOIN hero_attribute ON superhero.id = hero_attribute.hero_id\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE attribute.attribute_name = 'strength'\nGROUP BY superhero.id\nORDER BY hero_attribute.attribute_value DESC\nLIMIT 1;\t----- bird -----\tsuperhero",
  "281": "SELECT ROUND(100 * COUNT(s.id) / (SELECT COUNT(s.id) FROM superhero s JOIN gender g ON s.gender_id = g.id WHERE g.gender = 'Female'), 2) AS percentage\nFROM superhero s\nJOIN gender g ON s.gender_id = g.id\nJOIN publisher p ON s.publisher_id = p.id\nWHERE g.gender = 'Female' AND p.publisher_name = 'Marvel Comics';\t----- bird -----\tsuperhero",
  "282": "SELECT (\n    (SELECT weight_kg FROM superhero WHERE superhero_name = 'Emil Blonsky')\n    - (SELECT weight_kg FROM superhero WHERE superhero_name = 'Charles Chandler')\n) AS weight_difference;\t----- bird -----\tsuperhero",
  "283": "SELECT AVG(height_cm) FROM superhero;\t----- bird -----\tsuperhero",
  "284": "SELECT power_name FROM superpower JOIN hero_power ON superpower.id = hero_power.power_id WHERE hero_power.hero_id = (SELECT id FROM superhero WHERE superhero_name = 'Abomination');\t----- bird -----\tsuperhero",
  "285": "To find the fastest hero, we first need to assume that there is a table `speed` that stores the speed of each hero. The `speed` table should have a foreign key referencing the `id` of the `superhero` table.\n\nHere's the SQLite query to find the fastest hero:\n\n```sql\nSELECT superhero_name, speed\nFROM superhero\nJOIN speed ON superhero.id = speed.hero_id\nORDER BY speed DESC\nLIMIT 1;\n```\n\nThis query joins the `superhero` table with the `speed` table on the `id` column, orders the results in descending order by speed, and returns the top result (the fastest hero).\t----- bird -----\tsuperhero",
  "286": "SELECT a.attribute_name, ha.attribute_value\nFROM hero_attribute ha\nJOIN attribute a ON ha.attribute_id = a.id\nWHERE ha.hero_id = (SELECT id FROM superhero WHERE superhero_name = '3-D Man');\t----- bird -----\tsuperhero",
  "287": "SELECT superhero.id, superhero.superhero_name\nFROM superhero\nJOIN colour ON superhero.eye_colour_id = colour.id AND colour.colour = 'blue'\nJOIN colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id AND hair_colour.colour = 'brown'\nWHERE superhero.gender_id IS NOT NULL;\t----- bird -----\tsuperhero",
  "288": "SELECT publisher_name FROM publisher JOIN superhero ON publisher.id = superhero.publisher_id WHERE superhero.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');\t----- bird -----\tsuperhero",
  "289": "SELECT ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM superhero), 2) AS percentage\nFROM superhero\nJOIN colour ON superhero.eye_colour_id = colour.id\nWHERE colour.colour = 'blue'\t----- bird -----\tsuperhero",
  "290": "SELECT COUNT(*) as male_count FROM superhero\nJOIN gender ON superhero.gender_id = gender.id\nWHERE gender.gender = 'Male'\n\nUNION ALL\n\nSELECT COUNT(*) as female_count FROM superhero\nJOIN gender ON superhero.gender_id = gender.id\nWHERE gender.gender = 'Female'\n\nSELECT (male_count / female_count) as ratio FROM (\n    SELECT COUNT(*) as male_count FROM superhero\n    JOIN gender ON superhero.gender_id = gender.id\n    WHERE gender.gender = 'Male'\n\n    UNION ALL\n\n    SELECT COUNT(*) as female_count FROM superhero\n    JOIN gender ON superhero.gender_id = gender.id\n    WHERE gender.gender = 'Female'\n) AS ratio_table;\t----- bird -----\tsuperhero",
  "291": "SELECT superhero.hair_colour_id\nFROM superhero\nJOIN hero_attribute ON superhero.id = hero_attribute.hero_id\nJOIN attribute ON hero_attribute.attribute_id = attribute.id\nWHERE superhero.full_name = 'Karen Beecher-Duncan';\t----- bird -----\tsuperhero",
  "292": "sql\nSELECT COUNT(*) AS missing_weight_superheroes,\n       (SELECT COUNT(*) FROM colour WHERE colour = 'blue' AND id = s.eye_colour_id\n        MINUS\n        SELECT COUNT(*) FROM superhero WHERE skin_colour_id IS NULL) AS blue_eyes_no_eye_color_diff\nFROM superhero s\nWHERE weight_kg IS NULL\t----- bird -----\tsuperhero",
  "293": "SELECT COUNT(*) FROM superhero WHERE id IN (\n    SELECT hero_id FROM hero_power WHERE power_id IN (\n        SELECT id FROM superhero WHERE superhero_name IN (\n            SELECT superhero_name FROM superhero WHERE skin_colour_id = (\n                SELECT id FROM colour WHERE colour = 'green'\n            ) AND alignment_id = (\n                SELECT id FROM alignment WHERE alignment = 'villain'\n            )\n        )\n    )\n) AND skin_colour_id = (\n    SELECT id FROM colour WHERE colour = 'green'\n) AND alignment_id = (\n    SELECT id FROM alignment WHERE alignment = 'villain'\n)\t----- bird -----\tsuperhero",
  "294": "SELECT superhero_name\nFROM superhero\nJOIN hero_power ON superhero.id = hero_power.hero_id\nJOIN superpower ON hero_power.power_id = superpower.id\nWHERE superpower.power_name = 'control wind'\nORDER BY superhero_name ASC;\t----- bird -----\tsuperhero",
  "295": "SELECT `superhero`.`gender_id`\nFROM `superhero`\nJOIN `hero_power` ON `superhero`.`id` = `hero_power`.`hero_id`\nWHERE `superpower`.`power_name` = 'Phoenix Force'\nAND `superpower`.`id` = `hero_power`.`power_id`\nAND `superhero`.`id` = `hero_attribute`.`hero_id`\nAND EXISTS (\n    SELECT 1\n    FROM `attribute`\n    WHERE `attribute`.`attribute_name` = 'Ability'\n    AND `attribute`.`id` = `hero_attribute`.`attribute_id`\n    AND `hero_attribute`.`attribute_value` = 'Phoenix Force'\n);\t----- bird -----\tsuperhero",
  "296": "SELECT SUM(case when publisher_name = 'DC' then 1 else 0 end) as DC_superheroes,\n       SUM(case when publisher_name = 'Marvel Comics' then 1 else 0 end) as Marvel_superheroes,\n       SUM(case when publisher_name = 'DC' then 1 else 0 end) - SUM(case when publisher_name = 'Marvel Comics' then 1 else 0 end) as difference\nFROM superhero;\t----- bird -----\tsuperhero",
  "297": "SELECT `users`.`DisplayName`, `users`.`Reputation`\nFROM `users`\nWHERE `users`.`DisplayName` IN ('Harlan', 'Jarrod Dixon')\nORDER BY `users`.`Reputation` DESC\nLIMIT 1;\t----- bird -----\tcodebase_community",
  "298": "SELECT users.DisplayName\nFROM users\nWHERE YEAR(users.CreationDate) = 2011;\t----- bird -----\tcodebase_community",
  "299": "SELECT COUNT(*)\nFROM users\nWHERE LastAccessDate > '2014-09-01 00:00:00';\t----- bird -----\tcodebase_community",
  "300": "SELECT users.DisplayName\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE posts.Title = 'Eliciting priors from experts';\t----- bird -----\tcodebase_community",
  "301": "SELECT COUNT(*) FROM posts WHERE OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'csgillespie');\t----- bird -----\tcodebase_community",
  "302": "SELECT users.DisplayName\nFROM users\nJOIN posts ON users.Id = posts.LastEditorUserId\nWHERE posts.Title = 'Examples for teaching: Correlation does not mean causation';\t----- bird -----\tcodebase_community",
  "303": "SELECT COUNT(*)\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.CreationDate < (SELECT MIN(CreationDate) FROM users)\nAND posts.Score > 19;\t----- bird -----\tcodebase_community",
  "304": "SELECT posts.Body\nFROM posts\nJOIN tags ON posts.Id = tags.ExcerptPostId\nWHERE tags.TagName = 'bayesian';\t----- bird -----\tcodebase_community",
  "305": "SELECT AVG(posts.Score)\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName = 'csgillespie';\t----- bird -----\tcodebase_community",
  "306": "sql\nSELECT COUNT(*) as total_posts, COUNT(CASE WHEN posts.Score > 5 AND users.Age > 18 THEN 1 END) as elder_posts_score_over_5\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE posts.Score > 5\n\nSELECT (100.0 * (SELECT COUNT(*) as elder_posts_score_over_5 FROM (\n    SELECT * FROM (\n        SELECT COUNT(*) as total_posts, COUNT(CASE WHEN posts.Score > 5 AND users.Age > 18 THEN 1 END) as elder_posts_score_over_5\n        FROM posts\n        JOIN users ON posts.OwnerUserId = users.Id\n        WHERE posts.Score > 5\n    ) AS subquery\n) AS elder_posts_score_over_5) / (SELECT COUNT(*) as total_posts FROM (\n    SELECT * FROM (\n        SELECT COUNT(*) as total_posts, COUNT(CASE WHEN posts.Score > 5 THEN 1 END) as posts_score_over_5\n        FROM posts\n        JOIN users ON posts.OwnerUserId = users.Id\n        WHERE posts.Score > 5\n    ) AS subquery\n) AS total_posts) as percentage\n```\n\nThis SQL code calculates the percentage of posts with a score over 5 that are owned by elder users (users with an age greater than 18). It first calculates the number of posts with a score over 5 and the number of those posts that are owned by elder users. Then, it calculates the total number of posts with a score over 5. Finally, it calculates the percentage by dividing the number of elder posts with a score over 5 by the total number of posts with a score over 5.\t----- bird -----\tcodebase_community",
  "307": "SELECT posts.FavoriteCount\nFROM posts\nWHERE posts.Id = (\n    SELECT comments.PostId\n    FROM comments\n    JOIN users ON comments.UserId = users.Id\n    WHERE users.Id = 3025 AND comments.CreationDate = '2014-04-23 20:29:39'\n);\t----- bird -----\tcodebase_community",
  "308": "SELECT posts.Title, posts.AnswerCount, posts.CommentCount, posts.ClosedDate\nFROM posts\nJOIN comments ON posts.Id = comments.PostId\nJOIN users ON comments.UserId = users.Id\nWHERE users.Id = 23853 AND comments.CreationDate = '2013-07-12 09:08:18'\nAND posts.ClosedDate IS NULL;\t----- bird -----\tcodebase_community",
  "309": "SELECT COUNT(*) FROM posts WHERE OwnerDisplayName = 'Tiago Pasqualini';\t----- bird -----\tcodebase_community",
  "310": "SELECT users.DisplayName FROM users INNER JOIN votes ON users.Id = votes.UserId WHERE votes.Id = 6347;\t----- bird -----\tcodebase_community",
  "311": "SELECT COUNT(posts.Id) as PostCount, COUNT(votes.Id) as VoteCount\nFROM posts\nJOIN votes ON posts.Id = votes.PostId\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.Id = 24\n\nSELECT (PostCount - VoteCount) AS Difference\nFROM (\n    SELECT COUNT(posts.Id) as PostCount, COUNT(votes.Id) as VoteCount\n    FROM posts\n    JOIN votes ON posts.Id = votes.PostId\n    JOIN users ON posts.OwnerUserId = users.Id\n    WHERE users.Id = 24\n) AS SubQuery;\t----- bird -----\tcodebase_community",
  "312": "SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer';\t----- bird -----\tcodebase_community",
  "313": "SELECT comments.Id, comments.PostId, comments.Score, comments.Text, comments.CreationDate, users.DisplayName as UserDisplayName\nFROM comments\nJOIN users ON comments.UserId = users.Id\nWHERE comments.Score = 17\t----- bird -----\tcodebase_community",
  "314": "SELECT users.DisplayName\nFROM comments\nJOIN users ON comments.UserId = users.Id\nWHERE comments.Text = 'thank you user93!';\t----- bird -----\tcodebase_community",
  "315": "SELECT Users.DisplayName, Users.Reputation\nFROM users Users\nJOIN posts Posts ON Users.Id = Posts.OwnerUserId\nWHERE Posts.Title = 'Understanding what Dassault iSight is doing?';\t----- bird -----\tcodebase_community",
  "316": "SELECT users.DisplayName\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE posts.Title = 'Open source tools for visualizing multi-dimensional data';\t----- bird -----\tcodebase_community",
  "317": "sql\nSELECT comments.Text, users.DisplayName\nFROM comments\nJOIN posts ON comments.PostId = posts.Id\nJOIN users ON comments.UserId = users.Id\nWHERE posts.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\nAND comments.UserId IN (\n    SELECT LastEditorUserId\n    FROM postHistory\n    WHERE PostId = (\n        SELECT Id\n        FROM posts\n        WHERE Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\n    )\n)\t----- bird -----\tcodebase_community",
  "318": "sql\nSELECT users.DisplayName\nFROM users\nJOIN votes ON users.Id = votes.UserId\nJOIN posts ON votes.PostId = posts.Id\nWHERE posts.Title LIKE '%variance%' AND votes.BountyAmount = 50\t----- bird -----\tcodebase_community",
  "319": "SELECT posts.Title, comments.Text\nFROM posts\nJOIN tags ON posts.Id = tags.ExcerptPostId\nWHERE tags.TagName = 'humor'\n\nSELECT AVG(posts.ViewCount)\nFROM posts\nJOIN tags ON posts.Id = tags.ExcerptPostId\nWHERE tags.TagName = 'humor'\t----- bird -----\tcodebase_community",
  "320": "SELECT COUNT(*) FROM users JOIN badges ON users.Id = badges.UserId WHERE badges.Id IN (SELECT Id FROM badges GROUP BY UserId HAVING COUNT(*) > 5);\t----- bird -----\tcodebase_community",
  "321": "sql\nSELECT users.Id, posts.Id\nFROM users\nJOIN posts ON users.Id = posts.OwnerUserId\nJOIN postHistory ON posts.Id = postHistory.PostId\nWHERE users.Views > 1000\nGROUP BY users.Id, posts.Id\nHAVING COUNT(DISTINCT postHistory.Id) = 1;\n```\n\nThis query selects the user ID and post ID of users who have only one post history per post and have at least 1000 views. It joins the necessary tables, groups by user and post ID, and filters the results to only include those with a count of 1 for the distinct post history IDs.\t----- bird -----\tcodebase_community",
  "322": "To find the percentage difference of student badges given during 2010 and 2011, we first need to count the number of badges given in each year. Since the `badges` table does not have a year field, we will assume that the `Date` field contains the year.\n\n```sqlite\nSELECT\n    COUNT(*) as Badges2010,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2010 THEN 1 ELSE 0 END) as Badges2010Count,\n    COUNT(*) as Badges2011,\n    SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2011 THEN 1 ELSE 0 END) as Badges2011Count\nFROM badges\n```\n\nAfter getting the counts for both years, we can calculate the percentage difference:\n\n```sqlite\nSELECT\n    (Badges2011Count - Badges2010Count) * 100.0 / Badges2010Count as PercentageDifference\nFROM (\n    SELECT\n        COUNT(*) as Badges2010,\n        SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2010 THEN 1 ELSE 0 END) as Badges2010Count,\n        COUNT(*) as Badges2011,\n        SUM(CASE WHEN EXTRACT(YEAR FROM Date) = 2011 THEN 1 ELSE 0 END) as Badges2011Count\n    FROM badges\n)\t----- bird -----\tcodebase_community",
  "323": "SELECT AVG(UpVotes) as AverageUpVotes, AVG(Age) as AverageAge\nFROM users\nJOIN posts ON users.Id = posts.OwnerUserId\nWHERE posts.Id IN (\n    SELECT Id FROM posts\n    GROUP BY OwnerUserId\n    HAVING COUNT(Id) > 10\n)\t----- bird -----\tcodebase_community",
  "324": "SELECT AVG(votes_2010) / AVG(votes_2011) as ratio\nFROM (\n    SELECT COUNT(*) as votes_2010\n    FROM votes\n    WHERE CreationDate >= '2010-01-01' AND CreationDate < '2011-01-01'\n    UNION ALL\n    SELECT COUNT(*) as votes_2011\n    FROM votes\n    WHERE CreationDate >= '2011-01-01' AND CreationDate < '2012-01-01'\n)\t----- bird -----\tcodebase_community",
  "325": "SELECT PostId\nFROM posts\nWHERE OwnerDisplayName = 'slashnick'\nORDER BY AnswerCount DESC\nLIMIT 1;\t----- bird -----\tcodebase_community",
  "326": "sql\nSELECT posts.Title, posts.Id, posts.ViewCount, posts.CommentCount, posts.FavoriteCount\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE users.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')\nGROUP BY posts.Id\nORDER BY COALESCE(SUM(posts.ViewCount), 0) + COALESCE(SUM(posts.CommentCount), 0) + COALESCE(SUM(posts.FavoriteCount), 0) DESC;\n```\n\nThis query will return the titles, IDs, view counts, comment counts, and favorite counts for posts by Harvey Motulsky and Noah Snyder, sorted by their combined popularity (view count + comment count + favorite count) in descending order.\t----- bird -----\tcodebase_community",
  "327": "sql\nSELECT t.TagName\nFROM tags t\nJOIN posts p ON t.ExcerptPostId = p.Id\nLEFT JOIN comments c ON p.Id = c.PostId\nWHERE p.OwnerUserId = (SELECT Id FROM users WHERE DisplayName = 'Mark Meckes')\nAND c.Id IS NULL\nGROUP BY t.TagName\nHAVING COUNT(*) > 0;\t----- bird -----\tcodebase_community",
  "328": "SELECT ROUND(COUNT(p.Id) * 100.0 / (\n    SELECT COUNT(p.Id) FROM posts p\n    JOIN tags t ON p.Id = t.ExcerptPostId\n    WHERE p.CreationDate <= (SELECT MAX(CreationDate) FROM posts)\n    AND t.TagName = 'R'\n), 2) AS Percentage\nFROM posts p\nJOIN tags t ON p.Id = t.ExcerptPostId\nWHERE p.CreationDate <= (SELECT MAX(CreationDate) FROM posts)\nAND t.TagName IS NOT NULL\nAND t.TagName = 'R'\n```\n\nThis query calculates the percentage of posts that use the R language by counting the number of posts with the 'R' tag and dividing it by the total number of posts created up to the latest creation date. It first joins the posts and tags tables, filters for posts with a creation date up to the latest creation date, and then filters for posts with the 'R' tag. Finally, it calculates the percentage and rounds it to two decimal places.\t----- bird -----\tcodebase_community",
  "329": "SELECT posts.ViewCount - (\n    SELECT posts.ViewCount\n    FROM posts\n    WHERE posts.OwnerDisplayName = 'Amos'\n) AS Difference\nFROM posts\nWHERE posts.OwnerDisplayName = 'Mornington';\t----- bird -----\tcodebase_community",
  "330": "sql\nSELECT AVG(COUNT(postLinks.Id)) AS average_links\nFROM postLinks\nJOIN posts ON postLinks.PostId = posts.Id\nLEFT JOIN postHistory ON postLinks.PostId = postHistory.PostId\nWHERE posts.AnswerCount <= 2 AND postHistory.CreationDate BETWEEN '2010-01-01' AND '2010-12-31' AND postHistory.PostHistoryTypeId = 1\nGROUP BY YEAR(postHistory.CreationDate), MONTH(postHistory.CreationDate);\n```\n\nThis query calculates the average number of links created per month in 2010 for posts that have no more than 2 answers. It uses the `postHistory` table to filter posts based on the creation date and the number of answers, and the `postLinks` table to count the links. The `LEFT JOIN` is used to include posts that do not have a history record for the given year and month. The `PostHistoryTypeId = 1` is used to filter for the creation of links. The result is grouped by year and month to get the monthly average.\t----- bird -----\tcodebase_community",
  "331": "SELECT CreationDate FROM votes WHERE UserId = (SELECT Id FROM users WHERE DisplayName = 'chl') ORDER BY CreationDate ASC LIMIT 1;\t----- bird -----\tcodebase_community",
  "332": "SELECT users.DisplayName\nFROM badges\nJOIN users ON badges.UserId = users.Id\nWHERE badges.Name = 'Autobiographer'\nORDER BY badges.Date ASC\nLIMIT 1;\t----- bird -----\tcodebase_community",
  "333": "SELECT COUNT(*)\nFROM users\nJOIN posts ON users.Id = posts.OwnerUserId\nJOIN postVotes ON posts.Id = postVotes.PostId\nWHERE users.Location = 'United Kingdom' AND SUM(postVotes.VoteTypeId = 1) >= 4\t----- bird -----\tcodebase_community",
  "334": "SELECT Id, Title FROM posts WHERE Id = (\n    SELECT PostId FROM postHistory\n    INNER JOIN (\n        SELECT PostId, MAX(ViewCount) as max_view_count\n        FROM postHistory\n        GROUP BY PostId\n    ) as max_views ON postHistory.PostId = max_views.PostId AND postHistory.ViewCount = max_views.max_view_count\n    INNER JOIN users ON postHistory.OwnerUserId = users.Id\n    WHERE users.DisplayName = 'Harvey Motulsky'\n);\t----- bird -----\tcodebase_community",
  "335": "SELECT posts.Id, users.DisplayName\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE posts.CreationDate <= '2010-12-31 23:59:59'\nORDER BY posts.Score DESC, posts.CreationDate DESC\nLIMIT 1;\t----- bird -----\tcodebase_community",
  "336": "SELECT COUNT(*) as total_posts, COUNT(CASE WHEN users.Reputation > 1000 AND posts.CreationDate >= '2011-01-01' AND posts.CreationDate < '2011-12-31' THEN posts.Id END) as posts_with_reputation_over_1000\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE posts.CreationDate >= '2011-01-01' AND posts.CreationDate < '2011-12-31'\n\nSELECT (COUNT(*) as total_posts - COUNT(CASE WHEN users.Reputation > 1000 AND posts.CreationDate >= '2011-01-01' AND posts.CreationDate < '2011-12-31' THEN posts.Id END) / COUNT(*) as total_posts) * 100 as percentage\nFROM posts\nJOIN users ON posts.OwnerUserId = users.Id\nWHERE posts.CreationDate >= '2011-01-01' AND posts.CreationDate < '2011-12-31'\t----- bird -----\tcodebase_community",
  "337": "SELECT posts.Title, users.DisplayName AS LastEditorDisplayName\nFROM posts\nJOIN posts_history ON posts.Id = posts_history.PostId AND posts_history.PostHistoryTypeId = 1\nJOIN users ON posts_history.LastEditorUserId = users.Id\nWHERE posts.Title = 'Computer Game Datasets'\nORDER BY posts_history.CreationDate DESC\nLIMIT 1;\t----- bird -----\tcodebase_community",
  "338": "SELECT COUNT(*)\nFROM comments\nWHERE PostId = (\n    SELECT Id\n    FROM posts\n    ORDER BY Score DESC\n    LIMIT 1\n)\t----- bird -----\tcodebase_community",
  "339": "SELECT comments.Text, users.DisplayName\nFROM comments\nJOIN users ON comments.UserId = users.Id\nWHERE comments.PostId IN (\n    SELECT Id FROM posts WHERE Title = 'Analysing wind data with R'\n)\nORDER BY comments.CreationDate DESC\nLIMIT 10;\t----- bird -----\tcodebase_community",
  "340": "sql\nSELECT\n    COUNT(*) as total_posts,\n    SUM(CASE WHEN posts.Score > 50 THEN 1 ELSE 0 END) as posts_with_score_above_50,\n    users.Id as most_influential_user_id\nFROM\n    posts\nJOIN\n    users ON posts.OwnerUserId = users.Id\nJOIN\n    (\n        SELECT\n            UserId,\n            COUNT(*) as total_posts\n        FROM\n            posts\n        GROUP BY\n            UserId\n        ORDER BY\n            total_posts DESC\n        LIMIT 1\n    ) as most_prolific_user ON posts.OwnerUserId = most_prolific_user.UserId\nWHERE\n    posts.Score IS NOT NULL AND posts.OwnerUserId = most_prolific_user.UserId\nGROUP BY\n    posts.OwnerUserId\nHAVING\n    most_prolific_user.total_posts = (SELECT COUNT(*) FROM posts GROUP BY OwnerUserId ORDER BY COUNT(*) DESC LIMIT 1)\n\nSELECT\n    ROUND(100.0 * posts_with_score_above_50 / total_posts, 2) as percentage\nFROM\n    (\n        SELECT\n            total_posts,\n            posts_with_score_above_50,\n            most_influential_user_id\n        FROM\n            (\n                SELECT\n                    COUNT(*) as total_posts,\n                    SUM(CASE WHEN posts.Score > 50 THEN 1 ELSE 0 END) as posts_with_score_above_50,\n                    users.Id as most_influential_user_id\n                FROM\n                    posts\n                JOIN\n                    users ON posts.OwnerUserId = users.Id\n                JOIN\n                    (\n                        SELECT\n                            UserId,\n                            COUNT(*) as total_posts\n                        FROM\n                            posts\n                        GROUP BY\n                            UserId\n                        ORDER BY\n                            total_posts DESC\n                        LIMIT 1\n                    ) as most_prolific_user ON posts.OwnerUserId = most_prolific_user.UserId\n                WHERE\n                    posts.Score IS NOT NULL AND posts.OwnerUserId = most_prolific_user.UserId\n                GROUP BY\n                    posts.OwnerUserId\n                HAVING\n                    most_prolific_user.total_posts = (SELECT COUNT(*) FROM posts GROUP BY OwnerUserId ORDER BY COUNT(*) DESC LIMIT 1)\n            ) as subquery\n    ) as derived_query\t----- bird -----\tcodebase_community",
  "341": "SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample'\t----- bird -----\tcodebase_community",
  "342": "sql\nSELECT users.Reputation, users.UpVotes\nFROM users\nJOIN comments ON users.Id = comments.UserId\nWHERE comments.Text = 'fine, you win :)'\t----- bird -----\tcodebase_community",
  "343": "sql\nSELECT comments.Id, comments.Score\nFROM comments\nJOIN posts ON comments.PostId = posts.Id\nWHERE posts.ViewCount BETWEEN 100 AND 150\nORDER BY comments.Score DESC\nLIMIT 1;\t----- bird -----\tcodebase_community",
  "344": "SELECT COUNT(*)\nFROM comments\nWHERE PostId IN (\n    SELECT Id FROM posts WHERE CommentCount = 1\n) AND Score = 0;\t----- bird -----\tcodebase_community",
  "345": "sql\nSELECT COUNT(DISTINCT comments.UserId) as total_users_with_0_upvotes, COUNT(comments.UserId) FILTER (WHERE comments.UpVotes = 0) as users_with_0_upvotes\nFROM comments\nJOIN posts ON comments.PostId = posts.Id\nWHERE comments.Score BETWEEN 5 AND 10 AND comments.UpVotes = 0\n\nSELECT\n    ROUND(100.0 * COUNT(DISTINCT comments.UserId) FILTER (WHERE comments.UpVotes = 0) / COUNT(DISTINCT comments.UserId), 2) as percentage\nFROM comments\nJOIN posts ON comments.PostId = posts.Id\nWHERE comments.Score BETWEEN 5 AND 10\n```\n\nThe first query calculates the number of users with 0 upvotes among the comments with scores between 5 to 10. The second query calculates the percentage of users with 0 upvotes by dividing the number of users with 0 upvotes by the total number of users and rounding the result to 2 decimal places.\t----- bird -----\tcodebase_community",
  "346": "SELECT cards.id, cards.name\nFROM cards\nJOIN foreign_data ON cards.uuid = foreign_data.uuid\nWHERE foreign_data.type = 'Foil' AND cards.hasFoil = 1;\t----- bird -----\tcard_games",
  "347": "SELECT cards.name\nFROM cards\nWHERE cards.borderColor != 'Borderless'\nOR (cards.borderColor = 'Borderless' AND cards.hasFoil = 0);\t----- bird -----\tcard_games",
  "348": "SELECT c.name\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE c.rarity = 'Mythic Rare' AND l.format = 'Gladiator' AND l.status = 'Banned';\t----- bird -----\tcard_games",
  "349": "sql\nSELECT format, status\nFROM legalities\nWHERE uuid IN (\n    SELECT uuid\n    FROM cards\n    WHERE type = 'Artifact'\n        AND otherFaceIds IS NULL\n        AND setCode IN (\n            SELECT code\n            FROM sets\n            WHERE type = 'Vintage'\n        )\n)\t----- bird -----\tcard_games",
  "350": "sql\nSELECT id, artist\nFROM cards\nJOIN legalities ON cards.uuid = legalities.uuid\nWHERE format = 'Commander' AND power IS NULL;\t----- bird -----\tcard_games",
  "351": "sql\nSELECT c.name, r.text\nFROM cards c\nJOIN rulings r ON c.uuid = r.uuid\nJOIN foreign_data fd ON c.uuid = fd.uuid\nWHERE fd.flavorText = 'Stephen Daniel'\nAND (\n    c.flavorText IS NULL OR c.flavorText = ''\n    OR c.flavorText LIKE '%DEGRADED%'\n    OR c.flavorText LIKE '%MISSING%'\n)\t----- bird -----\tcard_games",
  "352": "sql\nSELECT cards.name, cards.artist, cards.isPromo\nFROM cards\nJOIN (\n    SELECT uuid, COUNT(id) as ruling_count\n    FROM rulings\n    GROUP BY uuid\n    ORDER BY ruling_count DESC\n    LIMIT 1\n) as most_rulings\nON cards.uuid = most_rulings.uuid;\n```\n\nThis SQL query will return the name, artist, and promotional status of the card with the most ruling information. It first groups the rulings by card UUID and counts the number of rulings for each card. Then it orders the results in descending order by the number of rulings and selects the top result. Finally, it joins this result with the cards table to get the name, artist, and promotional status of the card.\t----- bird -----\tcard_games",
  "353": "SELECT ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM cards WHERE availability != 'Chinese Simplified')) AS percentage\nFROM cards\nWHERE availability = 'Chinese Simplified';\t----- bird -----\tcard_games",
  "354": "SELECT COUNT(*) FROM cards WHERE power = 'Infinite';\t----- bird -----\tcard_games",
  "355": "SELECT borderColor FROM cards WHERE name = 'Ancestor\\'s Chosen'\t----- bird -----\tcard_games",
  "356": "SELECT text\nFROM rulings\nWHERE uuid = (\n    SELECT uuid\n    FROM cards\n    WHERE name = 'Benalish Knight'\n)\t----- bird -----\tcard_games",
  "357": "To find the percentage of borderless cards, we first need to count the number of borderless cards and the total number of cards. Here's the SQLite query for that:\n\n```sql\nSELECT\n    COUNT(CASE WHEN isOversized = 1 THEN 1 END) AS borderless_count,\n    COUNT(*) AS total_count\nFROM cards\n```\n\nAfter getting the counts, we can calculate the percentage by dividing the number of borderless cards by the total number of cards:\n\n```sql\nSELECT\n    ROUND(100.0 * borderless_count / total_count, 2) AS percentage_borderless\nFROM (\n    SELECT\n        COUNT(CASE WHEN isOversized = 1 THEN 1 END) AS borderless_count,\n        COUNT(*) AS total_count\n    FROM cards\n) AS counts\n```\n\nThis query calculates the percentage of borderless cards in the \"cards\" table.\t----- bird -----\tcard_games",
  "358": "SELECT COUNT(*) as count, SUM(CASE WHEN isStorySpotlight = 1 THEN 1 ELSE 0 END) as story_spotlight_count\nFROM cards\nWHERE language = 'French'\n\nSELECT (SUM(story_spotlight_count) / COUNT(*) * 100) as percentage\nFROM (\n    SELECT COUNT(*) as count, SUM(CASE WHEN isStorySpotlight = 1 THEN 1 ELSE 0 END) as story_spotlight_count\n    FROM cards\n    WHERE language = 'French'\n) as subquery\t----- bird -----\tcard_games",
  "359": "SELECT COUNT(*)\nFROM cards\nWHERE originalType = 'Summon - Angel' AND subtypes NOT LIKE '%Angel%';\t----- bird -----\tcard_games",
  "360": "SELECT id FROM cards WHERE duelDeck = 'a';\t----- bird -----\tcard_games",
  "361": "To find out how many banned cards are white border, we first need to find the cards that are banned and then filter those that have a white border. Here's the SQLite query:\n\n```sql\nSELECT COUNT(*)\nFROM cards\nJOIN legalities ON cards.uuid = legalities.uuid\nWHERE legalities.status = 'banned' AND cards.borderColor = 'White';\n```\n\nThis query joins the `cards` and `legalities` tables on the `uuid` field, filters for banned cards using the `status` column in the `legalities` table, and filters for white border cards using the `borderColor` column in the `cards` table. The `COUNT(*)` function is used to count the number of records that match the filtering conditions.\t----- bird -----\tcard_games",
  "362": "sql\nSELECT cards.name\nFROM cards\nJOIN foreign_data ON cards.uuid = foreign_data.uuid\nWHERE cards.colors LIKE '%Artifact%'\nAND cards.colors LIKE '%Black%'\nAND foreign_data.language IS NOT NULL;\t----- bird -----\tcard_games",
  "363": "SELECT name\nFROM cards\nWHERE layout = 'normal'\nAND frameVersion = '2003'\nAND borderColor = 'black'\nAND (availability LIKE '%paper%' OR availability LIKE '%mtgo%')\t----- bird -----\tcard_games",
  "364": "sql\nSELECT id, name\nFROM cards\nWHERE isStorySpotlight = 1 AND text IS NULL\n\nSELECT COUNT(*) AS total_story_spotlight_cards, COUNT(id) AS no_text_box_cards\nFROM (\n    SELECT id, name\n    FROM cards\n    WHERE isStorySpotlight = 1 AND text IS NULL\n) AS subquery\n\nSELECT (100.0 * COUNT(id)) / (SELECT COUNT(*) FROM cards WHERE isStorySpotlight = 1) AS percentage\nFROM (\n    SELECT id, name\n    FROM cards\n    WHERE isStorySpotlight = 1 AND text IS NULL\n) AS subquery\t----- bird -----\tcard_games",
  "365": "SELECT COUNT(*) FROM set_translations\nWHERE language = 'Brazilian Portuguese' AND set_translations.setCode IN (\n    SELECT code FROM sets WHERE block = 'Commander'\n)\t----- bird -----\tcard_games",
  "366": "SELECT translation\nFROM set_translations\nJOIN sets ON set_translations.setCode = sets.code\nJOIN cards ON sets.id = cards.setCode\nWHERE language = 'German' AND type IS NOT NULL;\t----- bird -----\tcard_games",
  "367": "SELECT COUNT(*)\nFROM cards\nWHERE power IS NULL AND keywords LIKE '%Triggered Ability%';\t----- bird -----\tcard_games",
  "368": "SELECT COUNT(*)\nFROM cards c\nJOIN legalities l ON c.uuid = l.uuid\nWHERE l.format = 'Premodern'\nAND c.name NOT IN (\n    SELECT name\n    FROM cards\n    WHERE otherFaceIds IS NOT NULL\n)\nAND EXISTS (\n    SELECT 1\n    FROM rulings r\n    WHERE r.uuid = c.uuid\n    AND r.text = 'This is a triggered mana ability.'\n);\t----- bird -----\tcard_games",
  "369": "SELECT name\nFROM cards\nJOIN foreign_data ON cards.uuid = foreign_data.uuid\nJOIN sets ON cards.setCode = sets.code\nJOIN set_translations ON sets.code = set_translations.setCode\nWHERE cards.artist = 'Matthew D. Wilson'\nAND cards.layout = 'normal'\nAND cards.borderColor = 'black'\nAND cards.type = 'Creature'\nAND set_translations.language = 'French'\t----- bird -----\tcard_games",
  "370": "SELECT language\nFROM set_translations\nWHERE setCode = 'RNA' AND totalSetSize = 180;\t----- bird -----\tcard_games",
  "371": "SELECT COUNT(*) as total, COUNT(CASE WHEN hasContentWarning = 0 THEN id END) as no_content_warning\nFROM cards\nJOIN legalities ON cards.uuid = legalities.uuid\nWHERE format = 'commander' AND status = 'legal'\n\nSELECT (COUNT(*) - COUNT(CASE WHEN hasContentWarning = 0 THEN id END)) / COUNT(*) * 100 AS percentage\nFROM (\n    SELECT id FROM cards\n    JOIN legalities ON cards.uuid = legalities.uuid\n    WHERE format = 'commander' AND status = 'legal'\n) AS subquery\t----- bird -----\tcard_games",
  "372": "To find the percentage of cards without power that are in French, we first need to count the number of cards without power in French and the total number of cards without power. Here's the SQLite query for that:\n\n```sql\nSELECT\n    COUNT(CASE WHEN cards.language = 'French' AND cards.power IS NULL THEN 1 END) AS french_cards_without_power,\n    COUNT(CASE WHEN cards.power IS NULL THEN 1 END) AS total_cards_without_power\nFROM\n    cards\n```\n\nTo get the percentage, we can use the following query:\n\n```sql\nSELECT\n    ROUND(\n        (\n            COUNT(CASE WHEN cards.language = 'French' AND cards.power IS NULL THEN 1 END) /\n            COUNT(CASE WHEN cards.power IS NULL THEN 1 END)\n        ) * 100,\n        2\n    ) AS percentage\nFROM\n    cards\n```\n\nThis query will return the percentage of cards without power that are in French.\t----- bird -----\tcard_games",
  "373": "SELECT foreign_data.language\nFROM foreign_data\nJOIN cards ON foreign_data.uuid = cards.uuid\nWHERE cards.multiverseId = 149934\nLIMIT 1;\t----- bird -----\tcard_games",
  "374": "SELECT COUNT(*) as total, COUNT(CASE WHEN layout != 'normal' THEN id END) as no_normal_layout\nFROM cards\nGROUP BY 1\nHAVING 2.0 * 100.0 / 1.0 AS proportion;\t----- bird -----\tcard_games",
  "375": "SELECT language FROM set_translations WHERE setCode = 'ARC';\t----- bird -----\tcard_games",
  "376": "SELECT foreign_data.language\nFROM foreign_data\nJOIN cards ON foreign_data.uuid = cards.uuid\nWHERE cards.name = 'A Pedra Fellwar';\t----- bird -----\tcard_games",
  "377": "SELECT CASE\n    WHEN (SELECT convertedManaCost FROM cards WHERE name = 'Serra Angel') > (SELECT convertedManaCost FROM cards WHERE name = 'Shrine Keeper') THEN 'Serra Angel'\n    ELSE 'Shrine Keeper'\nEND AS more_expensive_card;\t----- bird -----\tcard_games",
  "378": "SELECT translation\nFROM set_translations\nWHERE language = 'Italian' AND setCode = (\n    SELECT code\n    FROM sets\n    WHERE name = 'Ancestor''s Chosen'\n)\t----- bird -----\tcard_games",
  "379": "SELECT EXISTS (\n    SELECT 1\n    FROM foreign_data fd\n    JOIN cards c ON fd.uuid = c.uuid\n    WHERE c.name = 'Ancestor''s Chosen' AND fd.language = 'Korean'\n)\n\nThis SQL statement checks if there exists any row in the foreign_data table that matches the card name 'Ancestor's Chosen' and the language 'Korean'. The EXISTS function returns 1 if a matching row is found and 0 otherwise. The SELECT 1 inside the EXISTS function is just a placeholder to check if the query returns any rows.\t----- bird -----\tcard_games",
  "380": "SELECT COUNT(*)\nFROM cards\nWHERE setCode = 'Hauptset Zehnte Edition' AND artist = 'Adam Rex';\t----- bird -----\tcard_games",
  "381": "SELECT translation FROM set_translations WHERE language = 'Simplified Chinese' AND setCode = 'Eighth Edition';\t----- bird -----\tcard_games",
  "382": "SELECT EXISTS (SELECT 1 FROM cards WHERE name = 'Angel of Mercy' AND mtgoId IS NOT NULL)\n\nThis SQL statement checks if there exists a card named 'Angel of Mercy' in the 'cards' table, and if that card has an entry in the 'mtgoId' column, which indicates that the card is available on Magic: The Gathering Online. The 'EXISTS' function returns 1 if the condition is true, and 0 if it is false.\t----- bird -----\tcard_games",
  "383": "SELECT COUNT(*) FROM set_translations\nWHERE language = 'Italian' AND setCode IN (\n    SELECT code FROM sets WHERE block = 'Ice Age'\n)\t----- bird -----\tcard_games",
  "384": "SELECT `cards`.`name`\nFROM `cards`\nWHERE `cards`.`name` = 'Adarkar Valkyrie'\nAND EXISTS (\n    SELECT 1\n    FROM `legalities`\n    WHERE `legalities`.`format` NOT IN ('US')\n    AND `legalities`.`uuid` = `cards`.`uuid`\n)\t----- bird -----\tcard_games",
  "385": "SELECT COUNT(*)\nFROM sets\nJOIN set_translations ON sets.code = set_translations.setCode\nWHERE sets.baseSetSize < 100 AND set_translations.language = 'Italian';\t----- bird -----\tcard_games",
  "386": "SELECT artist FROM cards\nWHERE setCode = 'Coldsnap' AND artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')\t----- bird -----\tcard_games",
  "387": "SELECT COUNT(*)\nFROM cards\nWHERE setCode = 'Coldsnap' AND convertedManaCost > 5 AND power IS NULL\t----- bird -----\tcard_games",
  "388": "SELECT translation\nFROM set_translations\nJOIN foreign_data ON set_translations.setCode = foreign_data.setCode\nJOIN cards ON foreign_data.uuid = cards.uuid\nWHERE name = 'Ancestor''s Chosen' AND language = 'Italian';\t----- bird -----\tcard_games",
  "389": "SELECT translation\nFROM rulings\nJOIN cards ON cards.uuid = rulings.uuid\nJOIN sets ON cards.uuid = sets.uuid\nWHERE sets.code = 'Coldsnap' AND translation_language = 'Italian';\t----- bird -----\tcard_games",
  "390": "SELECT name\nFROM cards\nJOIN set_translations ON cards.uuid = set_translations.uuid\nWHERE set_translations.language = 'Italian' AND cards.setCode = 'Coldsnap'\nORDER BY convertedManaCost DESC\nLIMIT 1;\t----- bird -----\tcard_games",
  "391": "SELECT COUNT(*) AS count_7_cmc_cards, (SELECT COUNT(*) FROM cards WHERE setCode = 'Coldsnap') AS total_cards\nFROM cards\nWHERE convertedManaCost = 7\n\nSELECT (COUNT(*) / (SELECT COUNT(*) FROM cards WHERE setCode = 'Coldsnap')) * 100 AS percentage\nFROM cards\nWHERE convertedManaCost = 7 AND setCode = 'Coldsnap'\t----- bird -----\tcard_games",
  "392": "To find the percentage of incredibly powerful cards in the set Coldsnap, we first need to define what we mean by \"incredibly powerful\". For this example, let's assume a card is powerful if its converted mana cost (CMC) is 5 or more.\n\nHere's the SQLite query to find the count of powerful cards in the Coldsnap set and the total number of cards in the set:\n\n```sql\nSELECT\n    COUNT(*) AS powerful_count,\n    (SELECT COUNT(*) FROM cards WHERE setCode = 'Coldsnap') AS total_count\nFROM cards\nWHERE convertedManaCost >= 5 AND setCode = 'Coldsnap'\n```\n\nFinally, to get the percentage, we can use the following SQLite query:\n\n```sql\nSELECT\n    powerful_count / total_count AS powerful_percentage\nFROM (\n    SELECT\n        COUNT(*) AS powerful_count,\n        (SELECT COUNT(*) FROM cards WHERE setCode = 'Coldsnap') AS total_count\n    FROM cards\n    WHERE convertedManaCost >= 5 AND setCode = 'Coldsnap'\n) AS powerful_info\n```\n\nThis query calculates the percentage of powerful cards in the Coldsnap set by dividing the count of powerful cards by the total number of cards in the set.\t----- bird -----\tcard_games",
  "393": "To find the play format with the highest number of banned cards, we first need to count the number of banned cards for each format and then find the format with the maximum count. Here's the SQLite query to achieve this:\n\n```sql\nSELECT formats.name, COUNT(*) as banned_count\nFROM legalities\nJOIN cards ON cards.uuid = legalities.uuid\nJOIN sets ON cards.uuid = sets.uuid\nJOIN formats ON sets.code = formats.code\nWHERE legalities.status = 'banned'\nGROUP BY formats.name\nORDER BY banned_count DESC\nLIMIT 1;\n```\n\nThis query joins the necessary tables, filters for banned cards, groups the results by play format, counts the number of banned cards for each format, orders the results in descending order, and returns the format with the highest number of banned cards.\n\nTo get the names of all the cards that are banned in the identified play format, you can modify the query as follows:\n\n```sql\nSELECT cards.name\nFROM legalities\nJOIN cards ON cards.uuid = legalities.uuid\nJOIN sets ON cards.uuid = sets.uuid\nJOIN formats ON sets.code = formats.code\nWHERE legalities.status = 'banned'\nAND formats.name = (\n    SELECT formats.name\n    FROM legalities\n    JOIN cards ON cards.uuid = legalities.uuid\n    JOIN sets ON cards.uuid = sets.uuid\n    JOIN formats ON sets.code = formats.code\n    WHERE legalities.status = 'banned'\n    GROUP BY formats.name\n    ORDER BY COUNT(*) DESC\n    LIMIT 1\n)\nORDER BY cards.name;\n```\n\nThis query first identifies the play format with the highest number of banned cards, and then returns the names of all the cards that are banned in that format.\t----- bird -----\tcard_games",
  "394": "sql\nSELECT name, banned_format\nFROM cards\nJOIN legalities ON cards.uuid = legalities.uuid\nWHERE format = 'EDHRec' AND status = 'Banned' AND edhrecRank = 1;\t----- bird -----\tcard_games",
  "395": "sql\nSELECT name\nFROM cards\nJOIN sets ON cards.uuid = sets.uuid\nWHERE sets.code = 'HOU'\n\nSELECT format, name\nFROM legalities\nJOIN cards ON legalities.uuid = cards.uuid\nWHERE cards.uuid IN (\n    SELECT uuid\n    FROM cards\n    JOIN sets ON cards.uuid = sets.uuid\n    WHERE sets.code = 'HOU'\n)\t----- bird -----\tcard_games",
  "396": "SELECT sets.name\nFROM sets\nJOIN set_translations set_jp ON sets.code = set_translations.setCode AND set_translations.language = 'Japanese'\nJOIN set_translations set_kr ON sets.code = set_translations.setCode AND set_translations.language = 'Korean'\nWHERE set_jp.translation IS NULL AND set_kr.translation IS NOT NULL;\t----- bird -----\tcard_games",
  "397": "sql\nSELECT frameVersion, name\nFROM cards\nWHERE artist = 'Allen Williams';\n\nCREATE TEMPORARY TABLE banned_cards AS\nSELECT name\nFROM cards\nJOIN legalities ON cards.uuid = legalities.uuid\nWHERE format = 'Standard' AND status = 'Banned';\n\nSELECT name\nFROM cards\nWHERE artist = 'Allen Williams' AND name IN (SELECT name FROM banned_cards);\t----- bird -----\tcard_games",
  "398": "SELECT `bond_type`, COUNT(`bond_id`) as count\nFROM `bond`\nJOIN `connected` ON `bond`.`bond_id` = `connected`.`bond_id`\nGROUP BY `bond_type`\nORDER BY count DESC\nLIMIT 1;\t----- bird -----\ttoxicology",
  "399": "SELECT AVG(COUNT(a.atom_id)) FROM molecule m\nJOIN connected c ON m.molecule_id = c.molecule_id\nJOIN atom a ON c.atom_id = a.atom_id\nWHERE a.element = 'O' AND c.bond_id IN (\n  SELECT bond_id FROM bond WHERE bond_type = 'single'\n);\t----- bird -----\ttoxicology",
  "400": "To answer the question, we first need to identify carcinogenic molecules and single-bonded atoms. Then, we count the number of such pairs. Here's the SQLite query:\n\n```sql\nSELECT COUNT(*)\nFROM molecule m\nJOIN connected c ON m.molecule_id = c.molecule_id\nJOIN atom a ON c.atom_id = a.atom_id\nJOIN atom a2 ON c.atom_id2 = a2.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nWHERE m.label IS NOT NULL AND b.bond_type = 'single' AND a.element IN (carcinogenic_elements) AND a2.element IN (carcinogenic_elements)\n```\n\nReplace `(carcinogenic_elements)` with a list of carcinogenic elements. This query assumes that the `label` column in the `molecule` table contains the information about whether a molecule is carcinogenic or not, and that the list of carcinogenic elements is known.\t----- bird -----\ttoxicology",
  "401": "SELECT `molecule_id`\nFROM `molecule`\nJOIN `connected` ON `molecule`.`molecule_id` = `connected`.`molecule_id`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id`\nJOIN `atom` ON `connected`.`atom_id` = `atom`.`atom_id` AND `connected`.`atom_id2` = `atom`.`atom_id`\nWHERE `bond_type` = 'triple' AND `element` IN ('As', 'Pb', 'Sb') -- carcinogenic elements\nGROUP BY `molecule_id`\nHAVING COUNT(DISTINCT `element`) = 2 -- triple bond should be between two of the same element\t----- bird -----\ttoxicology",
  "402": "SELECT COUNT(*) * 100.0 / (\n  SELECT SUM(CASE WHEN bond_type = 'double' THEN 1 ELSE 0 END)\n  FROM bond\n  JOIN connected ON bond.bond_id = connected.bond_id\n  JOIN atom ON connected.atom_id = atom.atom_id\n  WHERE atom.element = 'Carbon'\n) AS percentage_of_carbon_in_double_bond_molecules\nFROM bond\nJOIN connected ON bond.bond_id = connected.bond_id\nJOIN atom ON connected.atom_id = atom.atom_id\nWHERE atom.element = 'Carbon' AND bond_type = 'double'\t----- bird -----\ttoxicology",
  "403": "SELECT `element` FROM `atom`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nJOIN `connected` AS `connected2` ON `atom`.`atom_id` = `connected2`.`atom_id2`\nWHERE `bond_id` IN (SELECT `bond_id` FROM `bond` WHERE `bond_id` = 'TR004_8_9')\nGROUP BY `atom_id`\nHAVING COUNT(DISTINCT `atom_id`) = 2;\t----- bird -----\ttoxicology",
  "404": "SELECT `element`\nFROM `atom`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nJOIN `connected` AS `connected2` ON `atom`.`atom_id` = `connected2`.`atom_id2`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id` AND `connected2`.`bond_id` = `bond`.`bond_id`\nWHERE `bond_type` = 'double';\t----- bird -----\ttoxicology",
  "405": "SELECT `label`, COUNT(`atom_id`) as count\nFROM `molecule`\nJOIN `atom` ON `molecule`.`molecule_id` = `atom`.`molecule_id`\nWHERE `element` = 'Hydrogen'\nGROUP BY `label`\nORDER BY count DESC\nLIMIT 1;\n```\n\nThis SQL code will return the most numerous label for atoms with hydrogen. It joins the molecule and atom tables, filters for hydrogen atoms, groups by the molecule label, orders the results in descending order by count, and limits the result to the top 1 row.\t----- bird -----\ttoxicology",
  "406": "SELECT element, COUNT(*) as count\nFROM atom\nJOIN connected ON atom.atom_id = connected.atom_id\nJOIN molecule ON molecule.molecule_id = connected.molecule_id\nWHERE molecule.label NOT LIKE '%carcinogenic%'\nGROUP BY element\nORDER BY count ASC\nLIMIT 1;\n```\n\nThis SQL code will return the element with the least number of occurrences in non-carcinogenic molecules. It joins the necessary tables, filters out the carcinogenic molecules, groups the results by element, orders them in ascending order, and limits the result to the least numerous element.\t----- bird -----\ttoxicology",
  "407": "SELECT `bond_type` FROM `bond` JOIN `connected` ON `bond`.`bond_id` = `connected`.`bond_id` WHERE `connected`.`atom_id` = 'TR004_8' AND `connected`.`atom_id2` = 'TR004_20';\t----- bird -----\ttoxicology",
  "408": "SELECT COUNT(*)\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\nJOIN molecule m ON b.molecule_id = m.molecule_id\nWHERE a.element IN ('Iodine', 'Sulfur') AND b.bond_type = 'single' AND m.label IS NOT NULL\t----- bird -----\ttoxicology",
  "409": "SELECT COUNT(m.molecule_id) as total_carcinogenic_molecules,\n       SUM(CASE WHEN a.element != 'Fluorine' THEN 1 ELSE 0 END) as non_fluorine_carcinogenic_molecules\nFROM molecule m\nJOIN atom a ON m.molecule_id = a.molecule_id\nWHERE m.label = 'carcinogenic'\nGROUP BY m.molecule_id\nHAVING non_fluorine_carcinogenic_molecules > 0\n```\n\nThis SQL query calculates the total number of carcinogenic molecules and the number of carcinogenic molecules that do not contain fluorine. It then filters the results to only show the molecules that have carcinogenic molecules without fluorine. The percentage can be calculated by dividing the number of non-fluorine carcinogenic molecules by the total number of carcinogenic molecules.\t----- bird -----\ttoxicology",
  "410": "sql\nSELECT COUNT(m.molecule_id) as total_carcinogenic_molecules,\n       SUM(CASE WHEN b.bond_type = 'triple' AND m.label = 'carcinogenic' THEN 1 ELSE 0 END) as carcinogenic_molecules_in_triple_bonds\nFROM molecule m\nJOIN atom a1 ON m.molecule_id = a1.molecule_id\nJOIN connected c1 ON a1.atom_id = c1.atom_id\nJOIN bond b1 ON c1.bond_id = b1.bond_id\nJOIN atom a2 ON c1.atom_id2 = a2.atom_id\nJOIN connected c2 ON a2.atom_id = c2.atom_id2\nJOIN bond b2 ON c2.bond_id = b2.bond_id\nJOIN molecule m2 ON m2.molecule_id = a2.molecule_id\nWHERE m.label = 'carcinogenic' AND b1.bond_type = 'triple' AND b2.bond_type = 'triple'\nGROUP BY m.molecule_id\n```\n\nThis SQL query will return the total number of carcinogenic molecules and the number of carcinogenic molecules that are in triple bonds. The query joins all the necessary tables and filters for carcinogenic molecules and triple bonds. The result is then grouped by molecule_id.\t----- bird -----\ttoxicology",
  "411": "SELECT `element` FROM `connected`\nJOIN `atom` ON `connected`.`atom_id` = `atom`.`atom_id`\nJOIN `molecule` ON `atom`.`molecule_id` = `molecule`.`molecule_id`\nWHERE `molecule`.`molecule_id` = 'TR000'\nGROUP BY `element`\nORDER BY `element` ASC\nLIMIT 3;\t----- bird -----\ttoxicology",
  "412": "sql\nSELECT ROUND(SUM(CASE WHEN bond_type = 'double' THEN 1 ELSE 0 END) / COUNT(*) * 100, 5) AS percentage_of_double_bonds\nFROM bond\nJOIN connected ON bond.bond_id = connected.bond_id\nJOIN molecule ON molecule.molecule_id = connected.molecule_id\nWHERE molecule.molecule_id = 'TR008'\t----- bird -----\ttoxicology",
  "413": "To find the percentage of molecules that are carcinogenic, we first need to count the number of carcinogenic molecules and the total number of molecules. Here's the SQLite SQL code:\n\n```sql\nSELECT\n    ROUND(100 * COUNT(DISTINCT m.molecule_id)\n          WHERE m.label LIKE '%carcinogenic%', 3) AS carcinogenic_percentage\nFROM\n    molecule m;\n```\n\nThis query calculates the percentage of carcinogenic molecules by dividing the count of carcinogenic molecules (those with 'carcinogenic' in the label) by the total number of molecules and then multiplying by 100. The result is rounded to three decimal places.\t----- bird -----\ttoxicology",
  "414": "SELECT ROUND(COUNT(a.atom_id) / (SELECT COUNT(*) FROM atom a JOIN connected c ON a.atom_id = c.atom_id2 WHERE c.molecule_id = 'TR206' AND a.element = 'H') * 100, 4) AS percentage\nFROM atom a\nJOIN connected c ON a.atom_id = c.atom_id2\nWHERE c.molecule_id = 'TR206' AND a.element = 'H'\t----- bird -----\ttoxicology",
  "415": "SELECT `element` FROM `atom`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nJOIN `connected` AS `connected2` ON `atom`.`atom_id` = `connected2`.`atom_id2`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id`\nWHERE `molecule_id` = 'TR060'\n\nUNION ALL\n\nSELECT `label` FROM `molecule` WHERE `molecule_id` = 'TR060'\t----- bird -----\ttoxicology",
  "416": "sql\nSELECT bond_type, COUNT(*) as bond_count\nFROM bond\nJOIN connected ON bond.bond_id = connected.bond_id\nJOIN atom ON connected.atom_id IN (atom.atom_id, atom.atom_id2)\nWHERE molecule_id = 'TR010'\nGROUP BY bond_type\nORDER BY bond_count DESC\nLIMIT 1;\n\nSELECT label, carcinogenic\nFROM molecule\nWHERE molecule_id = 'TR010';\n```\n\nThe first query will find the bond type that accounts for the majority of the bonds in molecule TR010. The second query will check if the molecule TR010 is carcinogenic.\t----- bird -----\ttoxicology",
  "417": "sql\nSELECT `molecule`.`molecule_id`, `molecule`.`label`\nFROM `molecule`\nJOIN `connected` ON `molecule`.`molecule_id` = `connected`.`molecule_id`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id`\nJOIN `atom` ON `connected`.`atom_id` = `atom`.`atom_id` AND `connected`.`atom_id2` = `atom`.`atom_id`\nWHERE `bond_type` = 'single' AND `atom`.`element` NOT IN ('As', 'Pb', 'Ni', 'Ar', 'Hg', 'Cd', 'Co', 'Cr', 'Pt', 'Rn', 'Sb', 'Te', 'Tl', 'U', 'V', 'Au', 'Bi', 'Po', 'Ce', 'Cm', 'Am', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og')\nGROUP BY `molecule`.`molecule_id`, `molecule`.`label`\nORDER BY `molecule`.`label` ASC\nLIMIT 3\t----- bird -----\ttoxicology",
  "418": "SELECT COUNT(*) FROM connected\nJOIN bond ON connected.bond_id = bond.bond_id\nJOIN atom ON connected.atom_id = atom.atom_id\nJOIN molecule ON atom.molecule_id = molecule.molecule_id\nWHERE atom.atom_id = '12' AND molecule.label = 'TR009'\t----- bird -----\ttoxicology",
  "419": "SELECT `bond_type`, `atom_id`, `atom_id2`\nFROM `bond`\nJOIN `connected` ON `bond`.`bond_id` = `connected`.`bond_id`\nJOIN `atom` ON `connected`.`atom_id` = `atom`.`atom_id`\nJOIN `atom` ON `connected`.`atom_id2` = `atom`.`atom_id`\nWHERE `bond`.`bond_id` = 'TR001_6_9';\t----- bird -----\ttoxicology",
  "420": "SELECT COUNT(*) FROM connected WHERE atom_id = '19'\t----- bird -----\ttoxicology",
  "421": "SELECT `element` FROM `atom`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nJOIN `connected` AS `connected2` ON `atom`.`atom_id` = `connected2`.`atom_id2`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id` AND `connected2`.`bond_id` = `bond`.`bond_id`\nJOIN `molecule` ON `atom`.`molecule_id` = `molecule`.`molecule_id`\nWHERE `molecule`.`molecule_id` = 'TR004';\t----- bird -----\ttoxicology",
  "422": "SELECT `molecule`.`molecule_id`, `molecule`.`label`\nFROM `molecule`\nJOIN `atom` ON `molecule`.`molecule_id` = `atom`.`molecule_id`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nWHERE `atom`.`atom_id` BETWEEN '21' AND '25'\nAND `molecule`.`label` LIKE '%carcinogenic%'\t----- bird -----\ttoxicology",
  "423": "SELECT `bond_id`\nFROM `bond`\nJOIN `connected` ON `bond`.`bond_id` = `connected`.`bond_id`\nJOIN `atom` ON (`connected`.`atom_id` = `atom`.`atom_id` OR `connected`.`atom_id2` = `atom`.`atom_id`)\nWHERE `atom`.`element` IN ('P', 'N');\t----- bird -----\ttoxicology",
  "424": "SELECT m.`molecule_id`, COUNT(b.`bond_id`) as double_bonds\nFROM `molecule` m\nJOIN `bond` b ON m.`molecule_id` = b.`molecule_id`\nWHERE b.`bond_type` = 'double'\nGROUP BY m.`molecule_id`\nORDER BY COUNT(b.`bond_id`) DESC\nLIMIT 1;\n\nSELECT c.`molecule_id`\nFROM `carcinogenic` c\nWHERE c.`molecule_id` = (\n  SELECT m.`molecule_id`\n  FROM `molecule` m\n  JOIN `bond` b ON m.`molecule_id` = b.`molecule_id`\n  WHERE b.`bond_type` = 'double'\n  GROUP BY m.`molecule_id`\n  ORDER BY COUNT(b.`bond_id`) DESC\n  LIMIT 1\n);\n```\n\nThis SQL code first finds the molecule with the most double bonds, then checks if that molecule is carcinogenic. The carcinogenic table is assumed to be already created with a structure like `CREATE TABLE carcinogenic (molecule_id TEXT NOT NULL, PRIMARY KEY (molecule_id))`.\t----- bird -----\ttoxicology",
  "425": "SELECT AVG(bonds_count)\nFROM (\n  SELECT COUNT(bond_id) AS bonds_count\n  FROM connected\n  JOIN atom ON atom.atom_id = connected.atom_id\n  WHERE atom.element = 'iodine'\n) AS subquery\t----- bird -----\ttoxicology",
  "426": "SELECT `element` FROM `atom` AS a\nWHERE NOT EXISTS (\n  SELECT 1 FROM `connected` AS c\n  WHERE c.`atom_id` = a.`atom_id`\n  OR c.`atom_id2` = a.`atom_id`\n)\nAND `element` IS NOT NULL\t----- bird -----\ttoxicology",
  "427": "SELECT `atom_id`\nFROM `atom`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id2`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id`\nJOIN `molecule` ON `bond`.`molecule_id` = `molecule`.`molecule_id`\nWHERE `molecule`.`molecule_id` = 'TR041' AND `bond_type` = 'triple';\t----- bird -----\ttoxicology",
  "428": "SELECT `element` FROM `atom` WHERE `atom_id` IN (SELECT `atom_id` FROM `connected` WHERE `molecule_id` = (SELECT `molecule_id` FROM `molecule` WHERE `molecule_id` = 'TR144_8_19'))\t----- bird -----\ttoxicology",
  "429": "SELECT element FROM atom\nJOIN connected ON atom.atom_id = connected.atom_id\nJOIN bond ON connected.bond_id = bond.bond_id\nWHERE bond_type = 'triple';\t----- bird -----\ttoxicology",
  "430": "To answer the question, we first need to establish that there is a relationship between the bond type and carcinogenicity. For the sake of this example, let's assume that only single bonds can be carcinogenic.\n\nNext, we need to count the number of carcinogenic single bonds and the total number of single bonds.\n\nHere's the SQLite SQL code to get the required information:\n\n```sql\nSELECT\n  COUNT(CASE WHEN bond_type = 'single' AND element IN ('C', 'N', 'P') THEN 1 END) as carcinogenic_single_bonds,\n  COUNT(CASE WHEN bond_type = 'single' THEN 1 END) as total_single_bonds\nFROM\n  connected\nJOIN\n  atom ON connected.atom_id = atom.atom_id\nJOIN\n  bond ON connected.bond_id = bond.bond_id\nJOIN\n  molecule ON bond.molecule_id = molecule.molecule_id\nWHERE\n  element IN ('C', 'N', 'P')\n```\n\nThis query joins the necessary tables, filters for single bonds, and checks if the element is one of the carcinogenic elements (C, N, P). It then counts the number of carcinogenic single bonds and the total number of single bonds. The result is the proportion of carcinogenic single bonds as a percentage with five decimal places.\t----- bird -----\ttoxicology",
  "431": "SELECT COUNT(*)\nFROM atom\nJOIN connected ON atom.atom_id = connected.atom_id\nJOIN bond ON connected.bond_id = bond.bond_id\nJOIN molecule ON bond.molecule_id = molecule.molecule_id\nWHERE atom.element IN ('phosphorus', 'bromine') AND bond.bond_type = 'triple' AND molecule.label IS NOT NULL\t----- bird -----\ttoxicology",
  "432": "SELECT SUM(CASE WHEN a.element = 'Cl' AND b.bond_type = 'single' THEN 1 ELSE 0 END) as total_chlorine_atoms,\n       (SELECT COUNT(*) FROM molecule) as total_molecules\nFROM molecule\nJOIN connected c ON molecule.molecule_id = c.molecule_id\nJOIN atom a ON c.atom_id = a.atom_id\nJOIN bond b ON c.bond_id = b.bond_id\n```\n\nThis SQL query calculates the total number of chlorine atoms in single bond molecules and the total number of molecules in the database. The result will be the percentage of chlorine among the single bond molecules.\t----- bird -----\ttoxicology",
  "433": "SELECT `element` FROM `atom`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id`\nJOIN `connected` ON `atom`.`atom_id` = `connected`.`atom_id2`\nJOIN `bond` ON `connected`.`bond_id` = `bond`.`bond_id`\nWHERE `bond`.`bond_id` = 'TR001_10_11';\t----- bird -----\ttoxicology",
  "434": "SELECT SUM(CASE WHEN atom.element = 'Cl' AND molecule.label = 'carcinogenic' THEN 1 ELSE 0 END) as total_cl_in_carcinogenic,\n       (SELECT COUNT(*) FROM molecule WHERE label = 'carcinogenic') as total_carcinogenic_molecules\nFROM connected\nJOIN atom ON connected.atom_id = atom.atom_id\nJOIN bond ON connected.bond_id = bond.bond_id\nJOIN molecule ON bond.molecule_id = molecule.molecule_id\n```\n\nThis SQL query calculates the number of chlorine atoms in carcinogenic molecules and the total number of carcinogenic molecules. The result is then used to calculate the percentage of chlorine in carcinogenic molecules.\t----- bird -----\ttoxicology",
  "435": "SELECT SUM(CASE WHEN atom.element = 'toxicology' AND molecule.label = 'carcinogenic' THEN 1 ELSE 0 END) as count\nFROM molecule\nJOIN connected ON molecule.molecule_id = connected.molecule_id\nJOIN atom ON connected.atom_id = atom.atom_id AND connected.atom_id2 = atom.atom_id + 3\nWHERE molecule.label = 'carcinogenic'\n```\n\nThis SQL query will sum the number of times the 4th atom of each carcinogenic molecule is toxicology. The `CASE` statement is used to check if the conditions are met, and the `SUM` function aggregates the results. The `JOIN` statements are used to connect the tables, and the `WHERE` clause filters the results to only include carcinogenic molecules.\t----- bird -----\ttoxicology",
  "436": "SELECT COUNT(CASE WHEN element = 'Hydrogen' THEN 1 END) as hydrogen_count, label\nFROM atom\nJOIN connected ON atom.atom_id = connected.atom_id\nJOIN molecule ON molecule.molecule_id = connected.molecule_id\nWHERE molecule.molecule_id = 'TR006'\nGROUP BY label;\t----- bird -----\ttoxicology",
  "437": "SELECT `molecule_id`, COUNT(`atom_id`) as `atom_count`\nFROM `molecule`\nJOIN `atom` ON `molecule_id` = `molecule_id`\nGROUP BY `molecule_id`\nHAVING `atom_count` > 5 AND `label` NOT LIKE '%carcinogenic%';\t----- bird -----\ttoxicology",
  "438": "SELECT COUNT(*)\nFROM schools s\nJOIN satscores ss ON s.CDSCode = ss.cds\nWHERE ss.CDSCode = s.CDSCode\nAND ss.SchoolCode = s.SchoolCode\nAND ss.DistrictCode = s.DistrictCode\nAND ss.CountyCode = s.CountyCode\nAND ss.CDSCode IN (\n    SELECT CDSCode\n    FROM schools\n    JOIN satscores ON schools.CDSCode = satscores.cds\n    WHERE satscores.AvgScrMath > 400\n    AND virtual = 1\n)\nAND virtual = 1;\t----- bird -----\tcalifornia_schools",
  "439": "SELECT CDSCode\nFROM schools\nWHERE Enrollment(K-12) > 500;\t----- bird -----\tcalifornia_schools",
  "440": "sql\nSELECT MAX(Percent (%%) Eligible Free (Ages 5-17))\nFROM frpm\nINNER JOIN satscores ON frpm.CDSCode = satscores.cds\nWHERE satscores.AvgScrRead >= 300 AND satscores.AvgScrMath >= 300 AND satscores.AvgScrWrite >= 300;\t----- bird -----\tcalifornia_schools",
  "441": "SELECT CharterNum, AVG(AvgScrWrite) as Average_Writing_Score\nFROM satscores\nJOIN schools ON satscores.cds = schools.CDSCode\nWHERE AvgScrWrite > 499\nGROUP BY CharterNum\nORDER BY Average_Writing_Score DESC;\t----- bird -----\tcalifornia_schools",
  "442": "SELECT School, Street, StreetAbr\nFROM schools\nWHERE ABS(Enrollment (K-12) - Enrollment (Ages 5-17)) > 30;\t----- bird -----\tcalifornia_schools",
  "443": "SELECT `School Name`\nFROM frpm\nJOIN schools ON frpm.CDSCode = schools.CDSCode\nWHERE `Percent (%) Eligible Free (K-12)` > 0.1\nAND NumGE1500 FROM satscores WHERE schools.CDSCode = satscores.cds IS NOT NULL;\t----- bird -----\tcalifornia_schools",
  "444": "SELECT schools.FundingType\nFROM schools\nJOIN satscores ON schools.CDSCode = satscores.cds\nWHERE schools.County = 'Riverside' AND satscores.AvgScrMath > 400;\t----- bird -----\tcalifornia_schools",
  "445": "sql\nSELECT School, Street, City, Zip, State, MailStreet, MailCity, MailZip, MailState\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nWHERE County = 'Monterey' AND SchoolType = 'High School' AND Enrollment (Ages 15-17) > 800 AND FRPM Count (Ages 15-17) > 800\t----- bird -----\tcalifornia_schools",
  "446": "sql\nSELECT School, AvgScrWrite, AdmEmail1, AdmEmail2, AdmEmail3\nFROM schools\nJOIN satscores ON schools.CDSCode = satscores.cds\nWHERE schools.OpenDate > '1991-01-01' AND (schools.ClosedDate IS NULL OR schools.ClosedDate < '2000-01-01')\nGROUP BY School, AvgScrWrite, AdmEmail1, AdmEmail2, AdmEmail3\nORDER BY AvgScrWrite DESC;\t----- bird -----\tcalifornia_schools",
  "447": "sql\nSELECT s.School, s.DOCType\nFROM schools s\nJOIN (\n    SELECT\n        CDSCode,\n        AVG(ENrollment (K-12) - Enrollment (Ages 15-17)) as avg_diff\n    FROM schools\n    WHERE Charter = 0\n    GROUP BY CDSCode\n) avg_enrollment_diff\nON s.CDSCode = avg_enrollment_diff.CDSCode\nWHERE s.Charter = 0 AND s.ENrollment (K-12) - s.Enrollment (Ages 15-17) > avg_enrollment_diff.avg_diff\t----- bird -----\tcalifornia_schools",
  "448": "sql\nSELECT (FRPM Count (K-12) / Enrollment (K-12)) * 100 AS 'Eligible Free Rate'\nFROM frpm\nWHERE School Code IN (\n    SELECT School Code FROM frpm\n    ORDER BY Enrollment (K-12) DESC\n    LIMIT 10, 2\n)\t----- bird -----\tcalifornia_schools",
  "449": "sql\nSELECT SchoolName, Percent (% ) Eligible Free (K-12)\nFROM frpm\nJOIN schools ON frpm.CDSCode = schools.CDSCode\nWHERE SchoolType = 'Regular' AND DistrictType = 'Unified' AND IRC = 66\nORDER BY FRPM Count (K-12) DESC, Percent (% ) Eligible Free (K-12) DESC\nLIMIT 5;\n```\n\nThis query selects the school name and the percentage of eligible free meals for grades 1-12 from the `frpm` table, joined with the `schools` table on the `CDSCode` field. It filters the results for regular schools and unified districts with an IRC of 66. The results are ordered by the free or reduced price meal count in descending order and then by the percentage of eligible free meals in descending order. The top 5 results are returned.\t----- bird -----\tcalifornia_schools",
  "450": "sql\nSELECT Street, City, Zip, State\nFROM schools\nWHERE EILName = (\n    SELECT EILName\n    FROM schools\n    ORDER BY Percent (%) Eligible Free (K-12) ASC\n    LIMIT 1\n)\t----- bird -----\tcalifornia_schools",
  "451": "sql\nSELECT schools.AdmFName1 || ' ' || schools.AdmLName1 AS Principal_Name, schools.DOC\nFROM schools\nJOIN (\n    SELECT cds, COUNT(*) as Num_SAT_1500\n    FROM satscores\n    WHERE AvgScrMath >= 800 AND AvgScrRead >= 800 AND AvgScrWrite >= 800 AND NumTstTakr > 0\n    GROUP BY cds\n    ORDER BY Num_SAT_1500 DESC\n    LIMIT 1\n) AS top_school\nON schools.CDSCode = top_school.cds;\n```\n\nThis SQL query will return the name of the principal and the DOC (District Office Code) of the school with the highest number of students scoring 1500 or more on the SAT. The subquery first filters the `satscores` table for SAT scores of 800 or more in each section and a non-zero number of test takers, then groups the results by CDSCode and orders them in descending order. The outer query then joins this subquery with the `schools` table to get the principal's name and DOC for the school with the highest number of students scoring 1500 or more on the SAT.\t----- bird -----\tcalifornia_schools",
  "452": "SELECT AVG(NumTstTakr)\nFROM satscores\nINNER JOIN schools ON schools.CDSCode = satscores.cds\nWHERE schools.OpenDate BETWEEN '1980-01-01' AND '1980-12-31'\nAND schools.County = 'Fresno';\t----- bird -----\tcalifornia_schools",
  "453": "sql\nSELECT schools.Phone\nFROM schools\nJOIN satscores ON schools.CDSCode = satscores.cds\nWHERE satscores.AvgScrRead = (\n    SELECT MIN(AvgScrRead)\n    FROM satscores\n    WHERE `County Code` = '06031' -- Fresno Unified's County Code\n)\t----- bird -----\tcalifornia_schools",
  "454": "sql\nSELECT SchoolName\nFROM schools s\nJOIN satscores ss ON s.CDSCode = ss.cds\nJOIN (\n    SELECT CDSCode, AVG(AvgScrRead) as avg_reading_score\n    FROM satscores\n    GROUP BY CDSCode\n    ORDER BY avg_reading_score DESC\n    LIMIT 5\n) t ON s.CDSCode = t.CDSCode\nWHERE Virtual = 'Y' AND s.County = t.CDSCode\n```\n\nThis query will return the names of virtual schools that are among the top 5 in their respective counties based on average reading scores. It first calculates the average reading scores for each school, orders them in descending order, and limits the result to the top 5. Then it joins this result with the schools table to get the school names for the top 5 schools in each county that are virtual.\t----- bird -----\tcalifornia_schools",
  "455": "SELECT schools.School, AVG(satscores.AvgScrWrite) as Average_Writing_Score\nFROM schools\nJOIN satscores ON schools.CDSCode = satscores.cds\nWHERE satscores.rtype = 'S' AND schools.AdmFName1 = 'Ricci' AND schools.AdmLName1 = 'Ulrich'\nGROUP BY schools.School\t----- bird -----\tcalifornia_schools",
  "456": "To find the state special schools with the highest number of enrollees from grades 1 through 12, we first need to join the `frpm` and `schools` tables on the `CDSCode` field. Then, we filter for schools with `School Type` as 'Special'. Finally, we group by the `State` field and sum the `Enrollment (K-12)` to find the schools with the highest enrollment.\n\nHere's the SQLite query:\n\n```sqlite\nSELECT State, SUM(Enrollment (K-12)) as TotalEnrollment\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nWHERE School Type = 'Special'\nGROUP BY State\nORDER BY TotalEnrollment DESC\nLIMIT 1;\n```\n\nThis query will return the state with the highest number of enrollees in state special schools from grades 1 through 12.\t----- bird -----\tcalifornia_schools",
  "457": "To answer the question, we first need to create a table that links the schools table with the date of opening. Then, we can filter for schools in Alameda County, under the jurisdiction of the Elementary School District, and for the year 1980, and finally, calculate the monthly average.\n\nHere's the SQLite code:\n\n```sql\nCREATE TABLE schools_opening_date AS\nSELECT CDSCode, OpenDate FROM schools;\n\nCREATE INDEX idx_schools_opening_date_openDate ON schools_opening_date (OpenDate);\n\nSELECT AVG(EXTRACT(MONTH FROM OpenDate)) as Monthly_Average\nFROM schools_opening_date\nWHERE County = 'Alameda'\nAND District = (SELECT DistrictCode FROM districts WHERE DistrictName = 'Elementary School District')\nAND EXTRACT(YEAR FROM OpenDate) = 1980;\n```\n\nThis code first creates a new table `schools_opening_date` that links the schools table with the opening date. Then, it creates an index on the `OpenDate` column to speed up the query. After that, it filters for schools in Alameda County, under the jurisdiction of the Elementary School District, and for the year 1980, and finally, calculates the monthly average by extracting the month from the opening date.\t----- bird -----\tcalifornia_schools",
  "458": "To find the ratio of merged Unified School District schools to merged Elementary School District schools in Orange County, we first need to count the number of each type of district in Orange County and then divide the count of Unified School Districts by the count of Elementary School Districts.\n\nHere's the SQLite query to achieve this:\n\n```sql\nSELECT\n    COUNT(CASE WHEN frpm.District_Type = 'Unified' THEN 1 END) AS unified_count,\n    COUNT(CASE WHEN frpm.District_Type = 'Elementary' THEN 1 END) AS elementary_count\nFROM\n    frpm\nWHERE\n    frpm.County_Code = '06031' -- Orange County code\nGROUP BY\n    frpm.District_Type;\n\nSELECT\n    unified_count / elementary_count AS ratio\nFROM\n    (\n        SELECT\n            COUNT(CASE WHEN frpm.District_Type = 'Unified' THEN 1 END) AS unified_count,\n            COUNT(CASE WHEN frpm.District_Type = 'Elementary' THEN 1 END) AS elementary_count\n        FROM\n            frpm\n        WHERE\n            frpm.County_Code = '06031' -- Orange County code\n        GROUP BY\n            frpm.District_Type\n    ) AS district_counts;\n```\n\nThis query first groups the `frpm` table by district type and counts the number of Unified and Elementary School Districts in Orange County. Then, it calculates the ratio of Unified School Districts to Elementary School Districts in Orange County.\t----- bird -----\tcalifornia_schools",
  "459": "sql\nSELECT Street, StreetAbr, School\nFROM schools\nJOIN (\n    SELECT cds, AVG(AvgScrMath) as AvgMathScore, DENSE_RANK() OVER (ORDER BY AVG(AvgScrMath) DESC) as rank\n    FROM satscores\n    GROUP BY cds\n) as scores\nON schools.CDSCode = scores.cds\nWHERE rank = 7;\t----- bird -----\tcalifornia_schools",
  "460": "SELECT COUNT(*)\nFROM schools s\nJOIN frpm f ON s.CDSCode = f.CDSCode\nWHERE s.County = 'Los Angeles' AND s.Charter = 0 AND f.`Percent (%) Eligible Free (K-12)` < 0.0018;\t----- bird -----\tcalifornia_schools",
  "461": "SELECT `Enrollment (Ages 5-17)`\nFROM frpm\nWHERE `School Name` = 'State Special School' AND `Academic Year` = '2014-2015' AND `County Code` = 'Fremont';\t----- bird -----\tcalifornia_schools",
  "462": "sql\nSELECT frpm.School_Name, frpm.Percent_(%)_Eligible_FRPM_(Ages_5-17)\nFROM frpm\nJOIN schools ON frpm.CDSCode = schools.CDSCode\nWHERE schools.County = 'Los Angeles'\nAND frpm.Low_Grade = 'Kindergarten'\nAND frpm.High_Grade = '9th grade';\t----- bird -----\tcalifornia_schools",
  "463": "sql\nSELECT COUNT(s.CDSCode)\nFROM schools s\nJOIN (\n    SELECT CDSCode\n    FROM schools\n    WHERE School IS NULL\n    AND County IN ('San Diego', 'Santa Barbara')\n) t ON s.CDSCode = t.CDSCode\n```\n\nThis query will count the number of schools in San Diego and Santa Barbara counties that do not have a physical building (School IS NULL).\t----- bird -----\tcalifornia_schools",
  "464": "SELECT `School Type`, `High Grade`\nFROM schools\nWHERE Longitude = (\n    SELECT MAX(Longitude) FROM schools\n)\t----- bird -----\tcalifornia_schools",
  "465": "sql\nSELECT cities.City, COUNT(DISTINCT schools.CDSCode) as Schools, COUNT(*) as SchoolsWithMultipleProvisionTypes\nFROM schools\nJOIN frpm ON schools.CDSCode = frpm.CDSCode\nJOIN satscores ON schools.CDSCode = satscores.cds\nJOIN (\n    SELECT DISTINCT County, City\n    FROM schools\n    WHERE SchoolType = 'Magnet'\n        AND EdOpsCode IN ('K', '1', '2', '3', '4', '5', '6', '7', '8')\n        AND EdOpsName IN ('Kindergarten', '1st Grade', '2nd Grade', '3rd Grade', '4th Grade', '5th Grade', '6th Grade', '7th Grade', '8th Grade')\n) as cities ON schools.County = cities.County AND schools.City = cities.City\nWHERE schools.CDSCode = satscores.cds\nGROUP BY cities.City, schools.CDSCode\nHAVING COUNT(DISTINCT frpm.EducationalOptionType) > 1;\n```\n\nThis SQL query first joins the schools, frpm, and satscores tables based on the CDSCode. It then filters the schools that offer a magnet program for Kindergarten to 8th grade. The subquery `cities` is used to get the cities where such schools exist.\n\nThe main query groups the results by city and school CDSCode. The HAVING clause filters the results to only include schools that offer multiple educational option types (FRPM Counts).\t----- bird -----\tcalifornia_schools",
  "466": "sql\nSELECT frpm.DistrictCode, frpm.Percent (% ) Eligible Free (K-12)\nFROM frpm\nJOIN schools ON frpm.CDSCode = schools.CDSCode\nWHERE schools.AdmFName1 = 'Alusine';\t----- bird -----\tcalifornia_schools",
  "467": "sql\nSELECT AdmEmail1, AdmEmail2, AdmEmail3\nFROM schools\nWHERE County = 'San Bernardino'\nAND City = 'San Bernardino City Unified'\nAND OpenDate BETWEEN '2009-01-01' AND '2010-12-31'\nAND SchoolType IN ('Public Intermediate/Middle Schools', 'Unified Schools');\t----- bird -----\tcalifornia_schools",
  "468": "SELECT COUNT(a.account_id)\nFROM account a\nJOIN trans t ON a.account_id = t.account_id\nJOIN district d ON a.district_id = d.district_id\nWHERE t.type = 'issuance' AND d.A2 = 'East Bohemia';\t----- bird -----\tfinancial",
  "469": "SELECT COUNT(district_id)\nFROM district\nWHERE AVG(CASE WHEN gender = 'Female' THEN salary ELSE NULL END) BETWEEN 6000 AND 10000;\n```\n\nAssuming there is a `salary` column in the `district` table to represent the average salary.\t----- bird -----\tfinancial",
  "470": "SELECT COUNT(*)\nFROM client\nJOIN district ON client.district_id = district.district_id\nWHERE client.gender = 'male' AND district.A16 = 'North Bohemia' AND district.A10 > 8000;\t----- bird -----\tfinancial",
  "471": "sql\nSELECT A1.account_id, AVG(A1.A10) as lowest_average_salary\nFROM district A1\nJOIN client C1 ON A1.district_id = C1.district_id\nJOIN disp D1 ON C1.client_id = D1.client_id\nJOIN account A2 ON D1.account_id = A2.account_id\nWHERE C1.gender = 'female'\nGROUP BY A1.district_id, A2.account_id\nORDER BY lowest_average_salary ASC, account_id ASC\nLIMIT 1;\n\nSELECT AVG(A1.A10) as highest_average_salary\nFROM district A1;\n\nSELECT highest_average_salary - lowest_average_salary as gap;\n```\n\nThis SQL code first finds the account number and lowest average salary for the oldest female client in each district, then finds the highest average salary for all districts, and finally calculates the gap between the lowest and highest average salaries.\t----- bird -----\tfinancial",
  "472": "SELECT client_id, account_id\nFROM client\nJOIN disp ON client.client_id = disp.client_id\nJOIN account ON disp.account_id = account.account_id\nLEFT JOIN loan ON account.account_id = loan.account_id\nLEFT JOIN trans ON account.account_id = trans.account_id\n\nWHERE (SELECT COUNT(*) FROM client WHERE birth_date <= (SELECT birth_date FROM client WHERE client_id = c.client_id)) = (SELECT COUNT(*) FROM client)\nAND (SELECT AVG(trans.amount) FROM trans WHERE trans.account_id = a.account_id) = (SELECT AVG(trans.amount) FROM trans GROUP BY account_id HAVING account_id = a.account_id)\nGROUP BY client_id, account_id;\t----- bird -----\tfinancial",
  "473": "SELECT account_id\nFROM loan\nWHERE loan.date = '1997-01-01' AND status = 'approved'\nORDER BY amount ASC\nLIMIT 1;\n```\n\nAfter finding the account_id with the lowest approved amount, you can use a subquery to find the accounts with the same weekly issuance statement (frequency = 'weekly') and the same district_id as the account found in the previous step.\n\n```\nSELECT account_id\nFROM account\nWHERE account.account_id = (\n    SELECT account_id\n    FROM loan\n    WHERE loan.date = '1997-01-01' AND status = 'approved'\n    ORDER BY amount ASC\n    LIMIT 1\n)\nAND account.district_id = (\n    SELECT district_id\n    FROM account\n    WHERE account_id = (\n        SELECT account_id\n        FROM loan\n        WHERE loan.date = '1997-01-01' AND status = 'approved'\n        ORDER BY amount ASC\n        LIMIT 1\n    )\n)\nAND frequency = 'weekly';\t----- bird -----\tfinancial",
  "474": "SELECT account_id, SUM(amount) as total_loan_amount\nFROM loan\nWHERE duration > 12 * 30 AND date_trunc('year', loan.date) = '1993-01-01'\nGROUP BY account_id\nORDER BY total_loan_amount DESC\nLIMIT 1;\n\nSELECT account_id\nFROM account\nWHERE account_id = (SELECT account_id FROM (\n    SELECT account_id, SUM(amount) as total_loan_amount\n    FROM loan\n    WHERE duration > 12 * 30 AND date_trunc('year', loan.date) = '1993-01-01'\n    GROUP BY account_id\n    ORDER BY total_loan_amount DESC\n    LIMIT 1\n));\n```\n\nThis SQL code first finds the account with the highest approved loan amount for accounts opened in 1993 and having a loan duration greater than 12 months. Then it finds the account_id of the account with the highest loan amount.\t----- bird -----\tfinancial",
  "475": "SELECT COUNT(client.client_id)\nFROM client\nJOIN account ON client.district_id = account.district_id\nJOIN district ON account.district_id = district.district_id\nWHERE client.gender = 'female' AND client.birth_date < '1950-01-01' AND district.A2 = 'Sokolov';\t----- bird -----\tfinancial",
  "476": "SELECT district_id\nFROM client\nJOIN disp ON client.client_id = disp.client_id\nJOIN account ON disp.account_id = account.account_id\nWHERE gender = 'Female' AND birth_date = '1976-01-29';\t----- bird -----\tfinancial",
  "477": "sql\nSELECT\n    (COUNT(c.client_id) * 100.0 / (\n        SELECT SUM(d.A11) FROM district WHERE A14 = 'South Bohemia'\n    )) AS percentage\nFROM\n    client c\nJOIN\n    district d ON c.district_id = d.district_id\nWHERE\n    d.A14 = 'South Bohemia' AND c.gender = 'Male'\t----- bird -----\tfinancial",
  "478": "sql\nSELECT\n    (trans.balance_1998 - trans.balance_1993) / trans.balance_1993 * 100 AS increase_rate\nFROM\n    (\n        SELECT\n            client.client_id,\n            account.account_id,\n            MIN(loan.date) AS loan_date,\n            trans.date AS balance_1993,\n            (SELECT trans.date FROM trans WHERE trans.account_id = account.account_id AND trans.date <= '1998-12-27') AS balance_1998,\n            trans.balance\n        FROM\n            client\n        JOIN\n            account ON client.district_id = account.district_id\n        JOIN\n            loan ON account.account_id = loan.account_id\n        JOIN\n            trans ON account.account_id = trans.account_id\n        WHERE\n            loan.date = (SELECT MIN(loan.date) FROM loan WHERE loan.account_id = account.account_id AND loan.date <= '1993-07-05')\n        GROUP BY\n            client.client_id, account.account_id, trans.balance\n    ) AS subquery\nWHERE\n    subquery.balance_1998 IS NOT NULL\t----- bird -----\tfinancial",
  "479": "sql\nSELECT ROUND(SUM(amount) / SUM(loan_amount) * 100, 2) AS percentage\nFROM (\n    SELECT amount, loan_id, loan_amount FROM loan\n    JOIN trans ON loan.account_id = trans.account_id\n    WHERE trans.type = 'Payment' AND trans.operation = 'Debit'\n    AND loan.status = 'Paid'\n) AS paid_loans\nJOIN (\n    SELECT SUM(amount) AS loan_amount FROM loan\n) AS total_loans;\n```\n\nThis SQL code calculates the percentage of loan amount that has been fully paid with no issue by joining the loan and trans tables, filtering for paid loans and loan payments, and then calculating the ratio of the sum of paid loan amounts to the total loan amount.\t----- bird -----\tfinancial",
  "480": "sql\nSELECT COUNT(*) as total_active_loans, SUM(amount) as total_loan_amount\nFROM loan\nWHERE amount < 100000 AND status = 'running';\n\nSELECT COUNT(*) as total_accounts\nFROM account;\n\nSELECT (COUNT(*) / (SELECT COUNT(*) FROM account)) * 100 as percentage\nFROM loan\nWHERE amount < 100000 AND status = 'running';\n\nSELECT (SUM(total_loan_amount) - (SELECT total_loan_amount FROM (\n    SELECT SUM(amount) as total_loan_amount\n    FROM loan\n    WHERE amount < 100000 AND status != 'running'\n) as subquery)) / (SELECT total_loan_amount FROM (\n    SELECT SUM(amount) as total_loan_amount\n    FROM loan\n    WHERE amount < 100000\n) as subquery) * 100 as percentage_of_loans_less_than_100000;\n\nSELECT (1 - (SELECT percentage_of_loans_less_than_100000 FROM (\n    SELECT (SUM(total_loan_amount) - (SELECT total_loan_amount FROM (\n        SELECT SUM(amount) as total_loan_amount\n        FROM loan\n        WHERE amount < 100000 AND status != 'running'\n    ) as subquery)) / (SELECT total_loan_amount FROM (\n        SELECT SUM(amount) as total_loan_amount\n        FROM loan\n        WHERE amount < 100000\n    ) as subquery) * 100 as percentage_of_loans_less_than_100000)) * 100) as percentage_of_accounts_with_loans_less_than_100000;\n\nSELECT (COUNT(*) - (SELECT percentage_of_accounts_with_loans_less_than_100000 FROM (\n    SELECT (1 - (SELECT percentage_of_loans_less_than_100000 FROM (\n        SELECT (SUM(total_loan_amount) - (SELECT total_loan_amount FROM (\n            SELECT SUM(amount) as total_loan_amount\n            FROM loan\n            WHERE amount < 100000 AND status != 'running'\n        ) as subquery)) / (SELECT total_loan_amount FROM (\n            SELECT SUM(amount) as total_loan_amount\n            FROM loan\n            WHERE amount < 100000\n        ) as subquery) * 100 as percentage_of_loans_less_than_100000)) * 100) as percentage_of_accounts_with_loans_less_than_100000)) * 100) as percentage_of_accounts_still_running_with_no_issue;\n```\n\nThis SQL code first calculates the total number of active loans, the total loan amount, the total number of accounts, and the percentage of loans less than USD 100,000. Then it calculates the percentage of accounts with loans less than USD 100,000, the percentage of accounts with any loan, and finally the percentage of accounts that are still running with no issues.\t----- bird -----\tfinancial",
  "481": "sql\nSELECT d.A16, (d.A11 - (SELECT A11 FROM district WHERE district_id = loan.account_district) / (SELECT A11 FROM district WHERE district_id = loan.account_district) * 100) as unemployment_rate_increment\nFROM loan\nJOIN account ON loan.account_id = account.account_id\nJOIN district ON account.district_id = district.district_id\nWHERE loan.status = 'running' AND loan.amount > account.balance\n```\n\nThis query will join the tables `loan`, `account`, and `district` to find loans where the client is in debt and the loan is still running. It then joins the `district` table again to get the unemployment rate for the district of the account. The subquery calculates the unemployment rate for the district in 1995. The main query calculates the unemployment rate increment by subtracting the 1995 rate from the 1996 rate and dividing by the 1995 rate, then multiplying by 100 to get a percentage. The `A16` column in the `district` table represents the state.\t----- bird -----\tfinancial",
  "482": "SELECT district_id, COUNT(client.client_id) as female_account_holders\nFROM client\nJOIN disp ON client.client_id = disp.client_id\nJOIN account ON disp.account_id = account.account_id\nWHERE client.gender = 'Female'\nGROUP BY district_id\nORDER BY female_account_holders DESC\nLIMIT 9;\t----- bird -----\tfinancial",
  "483": "SELECT COUNT(*)\nFROM loan\nWHERE account_id IN (\n    SELECT account_id\n    FROM loan\n    WHERE date BETWEEN '1995-01-01' AND '1997-12-31'\n        AND amount >= 250000\n        AND frequency = 'monthly'\n)\t----- bird -----\tfinancial",
  "484": "SELECT COUNT(*)\nFROM account AS a\nJOIN disp AS d ON a.account_id = d.account_id\nJOIN district AS dist ON a.district_id = dist.district_id\nWHERE dist.A16 = 1 AND d.type = 'contract'\t----- bird -----\tfinancial",
  "485": "SELECT COUNT(client.client_id)\nFROM client\nJOIN disp ON client.district_id = disp.district_id\nJOIN district ON disp.district_id = district.district_id\nWHERE district.A11 = (\n    SELECT MAX(district_A11) FROM (\n        SELECT district_A11 FROM district WHERE district_year = 1995 AND district_crime_type = (\n            SELECT district_crime_type FROM district WHERE district_year = 1995 AND district_crime_num = (\n                SELECT MAX(district_crime_num) FROM district WHERE district_year = 1995\n            )\n        )\n    )\n) AND client.gender = 'Male'\t----- bird -----\tfinancial",
  "486": "sql\nSELECT district.A1, SUM(trans.amount) as total_withdrawals\nFROM trans\nJOIN account ON trans.account_id = account.account_id\nJOIN client ON account.district_id = client.district_id\nJOIN disp ON account.account_id = disp.account_id\nJOIN district ON client.district_id = district.district_id\nWHERE trans.type = 'withdrawal' AND trans.type != 'credit card' AND trans.date = '1996-01-01'\nGROUP BY district.A1\nORDER BY total_withdrawals DESC\nLIMIT 10;\n```\n\nThis SQL query retrieves the top ten districts with the highest total withdrawals (excluding credit card transactions) for the month of January 1996. It joins the necessary tables, filters the transactions, groups the results by district names, and orders them in descending order of total withdrawals. Finally, it limits the results to the top ten.\t----- bird -----\tfinancial",
  "487": "SELECT COUNT(*)\nFROM account AS a\nJOIN disp AS d ON a.account_id = d.account_id\nJOIN district AS dist ON a.district_id = dist.district_id\nWHERE dist.A16 = 1 AND d.type = 'contract'\t----- bird -----\tfinancial",
  "488": "SELECT COUNT(client.client_id)\nFROM client\nJOIN disp ON client.district_id = disp.district_id\nJOIN district ON disp.district_id = district.district_id\nWHERE district.A11 = (\n    SELECT MAX(district_A11) FROM (\n        SELECT district_A11 FROM district WHERE district_year = 1995 AND district_crime_type = (\n            SELECT district_crime_type FROM district WHERE district_year = 1995 AND district_crime_num = (\n                SELECT MAX(district_crime_num) FROM district WHERE district_year = 1995\n            )\n        )\n    )\n) AND client.gender = 'Male'\t----- bird -----\tfinancial",
  "489": "SELECT account_id\nFROM account\nJOIN trans ON account.account_id = trans.account_id\nJOIN card ON account.account_id = card.disp_id\nWHERE trans.date = '1998-01-01' AND trans.type = 'credit'\nAND trans.amount < (\n    SELECT AVG(trans.amount)\n    FROM trans\n    WHERE trans.date = '1998-01-01' AND trans.type = 'credit'\n)\t----- bird -----\tfinancial",
  "490": "sql\nSELECT type\nFROM disp\nJOIN account ON account.account_id = disp.account_id\nJOIN district ON district.district_id = account.district_id\nWHERE district.A10 BETWEEN 8000 AND 9000 AND type NOT IN ('loan_eligible')\n```\n\nAssuming that there is a column named 'type' in the 'disp' table that indicates the account type, and 'loan_eligible' is one of the values for the account types that are not eligible for loans. Also, assuming that the 'A10' column in the 'district' table represents the average income of residents in the district.\t----- bird -----\tfinancial",
  "491": "SELECT AVG(crimes) as average_crimes\nFROM (\n    SELECT district.A14 as crimes\n    FROM district\n    JOIN account ON district.district_id = account.district_id\n    WHERE district.A14 > 4000 AND account.date >= '1997-01-01' AND district.A10 = 1995\n)\n```\n\nThis SQL code calculates the average number of crimes committed in 1995 in regions where the number exceeds 4000 and the region has accounts that are opened starting from the year 1997. The subquery filters the districts and accounts based on the given conditions, and the outer query calculates the average of the crimes in those filtered districts. The `A10` column in the `district` table represents the year.\t----- bird -----\tfinancial",
  "492": "SELECT trans.trans_id, trans.date, trans.amount\nFROM trans\nJOIN account ON trans.account_id = account.account_id\nJOIN client ON account.district_id = client.district_id\nWHERE client.client_id = 3356 AND trans.type = 'withdrawal' AND trans.operation = 'cash';\t----- bird -----\tfinancial",
  "493": "SELECT COUNT(client.client_id) as total_women, COUNT(client.client_id) FILTER (WHERE district.A10 > 10000) as women_with_high_salary\nFROM client\nJOIN district ON client.district_id = district.district_id\nWHERE client.gender = 'woman'\n\nSELECT COUNT(client.client_id) as total_clients\nFROM client\nJOIN district ON client.district_id = district.district_id\nWHERE district.A10 > 10000\n\nSELECT (COUNT(client.client_id) FILTER (WHERE district.A10 > 10000 AND client.gender = 'woman') / COUNT(client.client_id) FILTER (WHERE district.A10 > 10000)) * 100 as percentage\nFROM client\nJOIN district ON client.district_id = district.district_id\t----- bird -----\tfinancial",
  "494": "sql\nSELECT (SUM(loan.amount) OVER (\n    PARTITION BY client.gender\n    ORDER BY loan.date ASC\n    RANGE BETWEEN INTERVAL '1 year' PRECEDING AND INTERVAL '1 year'\n) - SUM(loan.amount) OVER (\n    PARTITION BY client.gender\n    ORDER BY loan.date ASC\n    RANGE BETWEEN INTERVAL '2 year' PRECEDING AND INTERVAL '1 year'\n) / (SUM(loan.amount) OVER (\n    PARTITION BY client.gender\n    ORDER BY loan.date ASC\n    RANGE BETWEEN INTERVAL '2 year' PRECEDING AND INTERVAL '1 year'\n) * 100) AS growth_rate\nFROM loan\nJOIN client ON loan.account_id = client.client_id\nWHERE client.gender = 'male' AND loan.date BETWEEN '1996-01-01' AND '1997-12-31';\t----- bird -----\tfinancial",
  "495": "SELECT COUNT(*) as statement_requests\nFROM account\nWHERE account_id = 3 AND frequency = 'statement';\n\nSELECT SUM(amount) as total_debit\nFROM trans\nWHERE account_id = 3 AND type = 'debit';\t----- bird -----\tfinancial",
  "496": "SELECT round(100 * count(case when gender = 'Male' and frequency = 'Weekly' then client_id end) /\n             (select count(*) from client where gender is not null), 2) as percentage\nfrom client\ninner join account on client.district_id = account.district_id\nwhere account.frequency = 'Weekly';\t----- bird -----\tfinancial",
  "497": "sql\nSELECT account_id\nFROM client\nJOIN account ON client.client_id = account.district_id\nJOIN district ON client.district_id = district.district_id\nWHERE gender = 'female'\nORDER BY birth_date ASC, AVG(district.A10) ASC\nLIMIT 1;\n```\n\nThis query will find the account number of the oldest female client with the lowest average salary by joining the necessary tables and ordering the results appropriately. The AVG(district.A10) function calculates the average salary for each client, and the ORDER BY clause sorts the results based on both the birth date and the average salary. The LIMIT 1 clause ensures that only the account number of the oldest female client with the lowest average salary is returned.\t----- bird -----\tfinancial",
  "498": "sql\nSELECT AVG(loan.amount)\nFROM loan\nJOIN trans ON loan.account_id = trans.account_id\nWHERE loan.status = 'running' AND trans.date <= loan.date AND trans.date >= loan.date - loan.duration * 30\n```\n\nThis SQL statement calculates the average amount of loans that are still on running contract, with a statement issuance after each transaction. It does this by joining the loan and trans tables on the account_id, filtering for loans with a status of 'running', transactions that occur between the loan date and the loan date minus the loan duration in days (assuming a 30-day month), and then calculating the average loan amount.\t----- bird -----\tfinancial",
  "499": "sql\nSELECT client_id, DATEDIF('now', birth_date, 'year') as age\nFROM client\nJOIN disp ON client.client_id = disp.client_id\nJOIN card ON disp.account_id = card.account_id\nWHERE card.type = 'high level' AND disp.type = 'loan_eligible';\n```\n\nThis query selects the client_id and age from the client table, joining it with the disp, card tables to get the required information. The WHERE clause filters the results to only include clients with high level credit cards and loan-eligible dispensations.\t----- bird -----\tfinancial"
}
